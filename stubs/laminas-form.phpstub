<?php
/**
 * @noinspection GrazieInspection
 * @noinspection HttpUrlsUsage
 * @noinspection PhpDeprecationInspection
 * @noinspection PhpDocRedundantThrowsInspection
 * @noinspection PhpDocSignatureInspection
 * @noinspection PhpDocSignatureIsNotCompleteInspection
 * @noinspection PhpFullyQualifiedNameUsageInspection
 * @noinspection PhpInconsistentReturnPointsInspection
 * @noinspection PhpMissingFieldTypeInspection
 * @noinspection PhpMissingParamTypeInspection
 * @noinspection PhpMissingParentConstructorInspection
 * @noinspection PhpMissingReturnTypeInspection
 * @noinspection PhpMixedReturnTypeCanBeReducedInspection
 * @noinspection PhpMultipleClassDeclarationsInspection
 * @noinspection PhpParameterNameChangedDuringInheritanceInspection
 * @noinspection PhpPluralMixedCanBeReplacedWithArrayInspection
 * @noinspection PhpPropertyOnlyWrittenInspection
 * @noinspection PhpReturnDocTypeMismatchInspection
 * @noinspection PhpUnnecessaryFullyQualifiedNameInspection
 * @noinspection PhpUnused
 * @noinspection PhpVarTagWithoutVariableNameInspection
 */

namespace Laminas\Form {
    interface ElementAttributeRemovalInterface
    {
        /**
         * Remove a single element attribute
         *
         * @return $this
         */
        public function removeAttribute(string $key);

        /**
         * Remove many attributes at once
         *
         * @return $this
         */
        public function removeAttributes(array $keys);

        /**
         * Remove all attributes at once
         *
         * @return $this
         */
        public function clearAttributes();
    }

    interface ElementInterface
    {
        /**
         * Set the name of this element
         *
         * In most cases, this will proxy to the attributes for storage, but is
         * present to indicate that elements are generally named.
         *
         * @return $this
         */
        public function setName(string $name);

        /**
         * Retrieve the element name
         */
        public function getName(): ?string;

        /**
         * Set options for an element
         *
         * @return $this
         */
        public function setOptions(iterable $options);

        /**
         * Set a single option for an element
         *
         * @return $this
         */
        public function setOption(string $key, mixed $value);

        /**
         * get the defined options
         *
         * @return array
         */
        public function getOptions(): array;

        /**
         * return the specified option
         *
         * @return null|mixed
         */
        public function getOption(string $option);

        /**
         * Set a single element attribute
         *
         * @return $this
         */
        public function setAttribute(string $key, mixed $value);

        /**
         * Retrieve a single element attribute
         *
         * @return mixed
         */
        public function getAttribute(string $key);

        /**
         * Return true if a specific attribute is set
         */
        public function hasAttribute(string $key): bool;

        /**
         * Set many attributes at once
         *
         * Implementation will decide if this will overwrite or merge.
         *
         * @return $this
         */
        public function setAttributes(iterable $arrayOrTraversable);

        /**
         * Retrieve all attributes at once
         */
        public function getAttributes(): array;

        /**
         * Set the value of the element
         *
         * @return $this
         */
        public function setValue(mixed $value);

        /**
         * Retrieve the element value
         *
         * @return mixed
         */
        public function getValue();

        /**
         * Set the label (if any) used for this element
         *
         * @return $this
         */
        public function setLabel(?string $label);

        /**
         * Retrieve the label (if any) used for this element
         */
        public function getLabel(): ?string;

        /**
         * Set a list of messages to report when validation fails
         *
         * @return $this
         */
        public function setMessages(iterable $messages);

        /**
         * Get validation error messages, if any
         *
         * Returns a list of validation failure messages, if any.
         */
        public function getMessages(): array;
    }

    interface LabelAwareInterface
    {
        /**
         * Set the label (if any) used for this element
         *
         * @return $this
         */
        public function setLabel(?string $label);

        /**
         * Retrieve the label (if any) used for this element
         */
        public function getLabel(): ?string;

        /**
         * Set the attributes to use with the label
         *
         * @param array $labelAttributes
         *
         * @return $this
         */
        public function setLabelAttributes(array $labelAttributes);

        /**
         * Get the attributes to use with the label
         *
         * @return array
         */
        public function getLabelAttributes(): array;

        /**
         * Set many label options at once
         *
         * Implementation will decide if this will overwrite or merge.
         *
         * @return $this
         */
        public function setLabelOptions(iterable $arrayOrTraversable);

        /**
         * Get label specific options
         *
         * @return array
         */
        public function getLabelOptions(): array;

        /**
         * Set a single label optionn
         *
         * @param mixed $value
         *
         * @return $this
         */
        public function setLabelOption(string $key, $value);

        /**
         * Retrieve a single label option
         *
         * @param int|string $key
         *
         * @return mixed|null
         */
        public function getLabelOption($key);

        /**
         * Remove a single label option
         *
         * @return $this
         */
        public function removeLabelOption(string $key);

        /**
         * Does the element has a specific label option ?
         */
        public function hasLabelOption(string $key): bool;

        /**
         * Remove many attributes at once
         *
         * @param array $keys
         *
         * @return $this
         */
        public function removeLabelOptions(array $keys);

        /**
         * Clear all label options
         *
         * @return $this
         */
        public function clearLabelOptions();
    }

    class Element implements \Laminas\Form\ElementAttributeRemovalInterface, \Laminas\Form\ElementInterface, \Laminas\Stdlib\InitializableInterface, \Laminas\Form\LabelAwareInterface
    {
        /** @var array */
        protected $attributes = [];
        /** @var null|string */
        protected $label;
        /** @var array */
        protected $labelAttributes = [];
        /**
         * Label specific options
         *
         * @var array
         */
        protected $labelOptions = [];
        /** @var array Validation error messages */
        protected $messages = [];
        /** @var array custom options */
        protected $options = [];
        /** @var mixed */
        protected $value;
        /** @var boolean */
        protected $hasValue = false;

        /**
         * @param null|int|string $name    Optional name for the element
         * @param iterable        $options Optional options for the element
         *
         * @throws Exception\InvalidArgumentException
         */
        public function __construct($name = null, iterable $options = []) {}

        /**
         * This function is automatically called when creating element with factory. It
         * allows to perform various operations (add elements...)
         *
         * @return void
         */
        public function init() {}

        /**
         * Set value for name
         *
         * @return $this
         */
        public function setName(string $name) {}

        /**
         * Get value for name
         */
        public function getName(): ?string {}

        /**
         * Set options for an element. Accepted options are:
         * - label: label to associate with the element
         * - label_attributes: attributes to use when the label is rendered
         * - label_options: label specific options
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setOptions(iterable $options) {}

        /**
         * Get defined options
         *
         * @return array
         */
        public function getOptions(): array {}

        /**
         * Return the specified option
         *
         * @return null|mixed
         */
        public function getOption(string $option) {}

        /**
         * Set a single option for an element
         *
         * @param mixed $value
         *
         * @return $this
         */
        public function setOption(string $key, $value) {}

        /**
         * Set a single element attribute
         *
         * @param mixed $value
         *
         * @return $this
         */
        public function setAttribute(string $key, $value) {}

        /**
         * Retrieve a single element attribute
         *
         * @return mixed|null
         */
        public function getAttribute(string $key) {}

        /**
         * Remove a single attribute
         *
         * @return $this
         */
        public function removeAttribute(string $key) {}

        /**
         * Does the element has a specific attribute ?
         */
        public function hasAttribute(string $key): bool {}

        /**
         * Set many attributes at once
         *
         * Implementation will decide if this will overwrite or merge.
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setAttributes(iterable $arrayOrTraversable) {}

        /**
         * Retrieve all attributes at once
         */
        public function getAttributes(): array {}

        /**
         * Remove many attributes at once
         *
         * @param array $keys
         *
         * @return $this
         */
        public function removeAttributes(array $keys) {}

        /**
         * Clear all attributes
         *
         * @return $this
         */
        public function clearAttributes() {}

        /**
         * Set the element value
         *
         * @param mixed $value
         *
         * @return $this
         */
        public function setValue($value) {}

        /**
         * Retrieve the element value
         *
         * @return mixed
         */
        public function getValue() {}

        /**
         * Set the label used for this element
         *
         * @return $this
         */
        public function setLabel(?string $label) {}

        /**
         * Retrieve the label used for this element
         */
        public function getLabel(): ?string {}

        /**
         * Set the attributes to use with the label
         *
         * @param array $labelAttributes
         *
         * @return $this
         */
        public function setLabelAttributes(array $labelAttributes) {}

        /**
         * Get the attributes to use with the label
         *
         * @return array
         */
        public function getLabelAttributes(): array {}

        /**
         * Set many label options at once
         *
         * Implementation will decide if this will overwrite or merge.
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setLabelOptions(iterable $arrayOrTraversable) {}

        /**
         * Get label specific options
         *
         * @return array
         */
        public function getLabelOptions(): array {}

        /**
         * Clear all label options
         *
         * @return $this
         */
        public function clearLabelOptions() {}

        /**
         * Remove many attributes at once
         *
         * @param array $keys
         *
         * @return $this
         */
        public function removeLabelOptions(array $keys) {}

        /**
         * Set a single label optionn
         *
         * @param mixed $value
         *
         * @return $this
         */
        public function setLabelOption(string $key, $value) {}

        /**
         * Retrieve a single label option
         *
         * @param int|string $key
         *
         * @return mixed|null
         */
        public function getLabelOption($key) {}

        /**
         * Remove a single label option
         *
         * @return $this
         */
        public function removeLabelOption(string $key) {}

        /**
         * Does the element has a specific label option ?
         */
        public function hasLabelOption(string $key): bool {}

        /**
         * Set a list of messages to report when validation fails
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setMessages(iterable $messages) {}

        /**
         * Get validation error messages, if any.
         *
         * Returns a list of validation failure messages, if any.
         */
        public function getMessages(): array {}

        public function hasValue(): bool {}
    }

    interface ElementPrepareAwareInterface
    {
        /**
         * Prepare the form element (mostly used for rendering purposes)
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void;
    }

    interface FormFactoryAwareInterface
    {
        /**
         * Compose a form factory into the object
         */
        public function setFormFactory(\Laminas\Form\Factory $formFactory);
    }

    interface FieldsetInterface extends \Countable, \IteratorAggregate, \Laminas\Form\ElementInterface, \Laminas\Form\ElementPrepareAwareInterface, \Laminas\Form\FormFactoryAwareInterface
    {
        /**
         * Add an element or fieldset
         *
         * $flags could contain metadata such as the alias under which to register
         * the element or fieldset, order in which to prioritize it, etc.
         *
         * @param array|\Traversable|ElementInterface $elementOrFieldset Typically, only allow objects implementing
         *                                                               ElementInterface; however, keeping it flexible
         *                                                               to allow a factory-based form
         *                                                               implementation as well
         * @param array                               $flags
         *
         * @return $this
         */
        public function add($elementOrFieldset, array $flags = []);

        /**
         * Does the fieldset have an element/fieldset by the given name?
         */
        public function has(string $elementOrFieldset): bool;

        /**
         * Retrieve a named element or fieldset
         */
        public function get(string $elementOrFieldset): \Laminas\Form\ElementInterface;

        /**
         * Remove a named element or fieldset
         *
         * @return $this
         */
        public function remove(string $elementOrFieldset);

        /**
         * Set/change the priority of an element or fieldset
         *
         * @return $this
         */
        public function setPriority(string $elementOrFieldset, int $priority);

        /**
         * Retrieve all attached elements
         *
         * Storage is an implementation detail of the concrete class.
         *
         * @return ElementInterface[]
         */
        public function getElements(): array;

        /**
         * Retrieve all attached fieldsets
         *
         * Storage is an implementation detail of the concrete class.
         *
         * @return FieldsetInterface[]
         */
        public function getFieldsets(): array;

        /**
         * Recursively populate value attributes of elements
         */
        public function populateValues(iterable $data): void;

        /**
         * Set the object used by the hydrator
         *
         * @param mixed $object
         *
         * @return $this
         */
        public function setObject($object);

        /**
         * Get the object used by the hydrator
         *
         * @return mixed
         */
        public function getObject();

        /**
         * Checks if the object can be set in this fieldset
         */
        public function allowObjectBinding(object $object): bool;

        /**
         * Set the hydrator to use when binding an object to the element
         *
         * @return $this
         */
        public function setHydrator(\Laminas\Hydrator\HydratorInterface $hydrator);

        /**
         * Get the hydrator used when binding an object to the element
         */
        public function getHydrator(): ?\Laminas\Hydrator\HydratorInterface;

        /**
         * Bind values to the bound object
         *
         * @return mixed
         */
        public function bindValues(array $values = []);

        /**
         * Checks if this fieldset can bind data
         */
        public function allowValueBinding(): bool;
    }

    class Fieldset extends \Laminas\Form\Element implements \Laminas\Form\FieldsetInterface
    {
        /** @var null|Factory */
        protected $factory;
        /** @var array */
        protected $elements = [];
        /** @var FieldsetInterface[] */
        protected $fieldsets = [];
        /** @var array */
        protected $messages = [];
        /** @var \Laminas\Stdlib\PriorityList */
        protected $iterator;
        /**
         * Hydrator to use with bound object
         *
         * @var null|\Laminas\Hydrator\HydratorInterface
         */
        protected $hydrator;
        /**
         * The object bound to this fieldset, if any
         *
         * @var null|object
         */
        protected $object;
        /**
         * Should this fieldset be used as a base fieldset in the parent form ?
         *
         * @var bool
         */
        protected $useAsBaseFieldset = false;
        /**
         * The class or interface of objects that can be bound to this fieldset.
         *
         * @var null|class-string
         */
        protected $allowedObjectBindingClass;

        /**
         * @param null|int|string $name    Optional name for the element
         * @param array           $options Optional options for the element
         */
        public function __construct($name = null, array $options = []) {}

        /**
         * Set options for a fieldset. Accepted options are:
         * - use_as_base_fieldset: is this fieldset use as the base fieldset?
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setOptions(iterable $options) {}

        /**
         * Compose a form factory to use when calling add() with a non-element/fieldset
         *
         * @return $this
         */
        public function setFormFactory(\Laminas\Form\Factory $formFactory) {}

        /**
         * Retrieve composed form factory
         *
         * Lazy-loads one if none present.
         */
        public function getFormFactory(): \Laminas\Form\Factory {}

        /**
         * Add an element or fieldset
         *
         * $flags could contain metadata such as the alias under which to register
         * the element or fieldset, order in which to prioritize it, etc.
         *
         * @param array|\Traversable|ElementInterface $elementOrFieldset
         * @param array                               $flags
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         * @todo   Should we detect if the element/fieldset name conflicts?
         */
        public function add($elementOrFieldset, array $flags = []) {}

        /**
         * Does the fieldset have an element/fieldset by the given name?
         */
        public function has(string $elementOrFieldset): bool {}

        /**
         * Retrieve a named element or fieldset
         *
         * @return FieldsetInterface|ElementInterface
         */
        public function get(string $elementOrFieldset): \Laminas\Form\ElementInterface {}

        /**
         * Remove a named element or fieldset
         *
         * @return $this
         */
        public function remove(string $elementOrFieldset) {}

        /**
         * Set/change the priority of an element or fieldset
         *
         * @return $this
         */
        public function setPriority(string $elementOrFieldset, int $priority) {}

        /**
         * Retrieve all attached elements
         *
         * Storage is an implementation detail of the concrete class.
         */
        public function getElements(): array {}

        /**
         * Retrieve all attached fieldsets
         *
         * Storage is an implementation detail of the concrete class.
         */
        public function getFieldsets(): array {}

        /**
         * Set a hash of element names/messages to use when validation fails
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setMessages(iterable $messages) {}

        /**
         * Get validation error messages, if any
         *
         * Returns a hash of element names/messages for all elements failing
         * validation, or, if $elementName is provided, messages for that element
         * only.
         *
         * @throws Exception\InvalidArgumentException
         */
        public function getMessages(?string $elementName = null): array {}

        /**
         * Ensures state is ready for use. Here, we append the name of the fieldsets to every elements in order to avoid
         * name clashes if the same fieldset is used multiple times
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}

        /**
         * Recursively populate values of attached elements and fieldsets
         *
         * @param iterable $data
         *
         * @throws Exception\InvalidArgumentException
         */
        public function populateValues(iterable $data): void {}

        /**
         * Countable: return count of attached elements/fieldsets
         */
        public function count(): int {}

        /**
         * IteratorAggregate: return internal iterator
         */
        public function getIterator(): \Laminas\Stdlib\PriorityList {}

        /**
         * Set the object used by the hydrator
         *
         * @param object $object
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setObject($object) {}

        /**
         * Get the object used by the hydrator
         *
         * @return mixed
         */
        public function getObject() {}

        /**
         * Set the class or interface of objects that can be bound to this fieldset.
         *
         * @param null|class-string $allowObjectBindingClass
         */
        public function setAllowedObjectBindingClass(?string $allowObjectBindingClass): void {}

        /**
         * Get The class or interface of objects that can be bound to this fieldset.
         *
         * @return null|class-string
         */
        public function allowedObjectBindingClass(): ?string {}

        /**
         * Checks if the object can be set in this fieldset
         *
         * @param object|array $object
         */
        public function allowObjectBinding($object): bool {}

        /**
         * Set the hydrator to use when binding an object to the element
         *
         * @return $this
         */
        public function setHydrator(\Laminas\Hydrator\HydratorInterface $hydrator) {}

        /**
         * Set the hydrator by name to use when binding an object to the element.
         *
         * The form element manager {@see FormElementManager} is used via the
         * form factory {@see Factory} to fetch the hydrator.
         *
         * @throws Exception\DomainException If hydrator is not found in hydrator
         *                                   manager or service manager.
         */
        public function setHydratorByName(string $hydratorName): void {}

        /**
         * Get the hydrator used when binding an object to the fieldset
         *
         * If no hydrator is present and object implements HydratorAwareInterface,
         * hydrator will be retrieved from the object.
         *
         * Will lazy-load Hydrator\ArraySerializable if none is present.
         */
        public function getHydrator(): \Laminas\Hydrator\HydratorInterface {}

        /**
         * Checks if this fieldset can bind data
         */
        public function allowValueBinding(): bool {}

        /**
         * Bind values to the bound object
         *
         * @param array      $values
         * @param array|null $validationGroup
         *
         * @return mixed
         */
        public function bindValues(array $values = [], ?array $validationGroup = null) {}

        /**
         * Set if this fieldset is used as a base fieldset
         *
         * @return $this
         */
        public function setUseAsBaseFieldset(bool $useAsBaseFieldset) {}

        /**
         * Is this fieldset use as a base fieldset for a form ?
         */
        public function useAsBaseFieldset(): bool {}

        /**
         * Extract values from the bound object
         *
         * @return array
         */
        protected function extract(): array {}

        /**
         * Make a deep clone of a fieldset
         *
         * @return void
         */
        public function __clone() {}
    }

    final class InputFilterProviderFieldset extends \Laminas\Form\Fieldset implements \Laminas\InputFilter\InputFilterProviderInterface
    {
        public function getInputFilterSpecification(): array {}

        public function setInputFilterSpecification(iterable $filterSpec): void {}

        /**
         * Set options for a fieldset. Accepted options are:
         * - input_filter_spec: specification to be returned by getInputFilterSpecification
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setOptions(iterable $options) {}
    }

    interface FormInterface extends \Laminas\Form\FieldsetInterface
    {
        public const BIND_ON_VALIDATE  = 0x0;
        public const BIND_MANUAL       = 0x1;
        public const VALUES_NORMALIZED = 0x11;
        public const VALUES_RAW        = 0x12;
        public const VALUES_AS_ARRAY   = 0x13;

        /**
         * Set data to validate and/or populate elements
         *
         * Typically, also passes data on to the composed input filter.
         *
         * @return $this
         */
        public function setData(iterable $data);

        /**
         * Bind an object to the element
         *
         * Allows populating the object with validated values.
         *
         * @return mixed
         */
        public function bind(object $object, int $flags = \Laminas\Form\FormInterface::VALUES_NORMALIZED);

        /**
         * Whether or not to bind values to the bound object when validation succeeds
         *
         * @return $this
         */
        public function setBindOnValidate(int $bindOnValidateFlag);

        /**
         * Set input filter
         *
         * @return $this
         */
        public function setInputFilter(\Laminas\InputFilter\InputFilterInterface $inputFilter);

        /**
         * Retrieve input filter
         */
        public function getInputFilter(): \Laminas\InputFilter\InputFilterInterface;

        /**
         * Validate the form
         *
         * Typically, will proxy to the composed input filter.
         */
        public function isValid(): bool;

        /**
         * Retrieve the validated data
         *
         * By default, retrieves normalized values; pass one of the VALUES_*
         * constants to shape the behavior.
         *
         * @return array|object
         *
         * @psalm-taint-source input
         */
        public function getData(int $flag = \Laminas\Form\FormInterface::VALUES_NORMALIZED);

        /**
         * Set the validation group (set of values to validate)
         *
         * Typically, proxies to the composed input filter
         *
         * @return $this
         */
        public function setValidationGroup(array $group);

        /**
         * Reset the form to validate all elements
         */
        public function setValidateAll(): void;
    }

    /**
     * laminas-servicemanager v3-compatible plugin manager implementation for form elements.
     *
     * Enforces that elements retrieved are instances of ElementInterface.
     *
     * @final
     * @extends \Laminas\ServiceManager\AbstractPluginManager<ElementInterface>
     */
    class FormElementManager extends \Laminas\ServiceManager\AbstractPluginManager
    {
        /**
         * Aliases for default set of helpers
         *
         * @var array
         */
        protected $aliases = ['button'         => \Laminas\Form\Element\Button::class, 'Button' => \Laminas\Form\Element\Button::class,
                              'captcha'        => \Laminas\Form\Element\Captcha::class, 'Captcha' => \Laminas\Form\Element\Captcha::class,
                              'checkbox'       => \Laminas\Form\Element\Checkbox::class, 'Checkbox' => \Laminas\Form\Element\Checkbox::class,
                              'collection'     => \Laminas\Form\Element\Collection::class, 'Collection' => \Laminas\Form\Element\Collection::class,
                              'color'          => \Laminas\Form\Element\Color::class, 'Color' => \Laminas\Form\Element\Color::class, 'csrf' => \Laminas\Form\Element\Csrf::class,
                              'Csrf'           => \Laminas\Form\Element\Csrf::class, 'date' => \Laminas\Form\Element\Date::class, 'Date' => \Laminas\Form\Element\Date::class,
                              'dateselect'     => \Laminas\Form\Element\DateSelect::class, 'dateSelect' => \Laminas\Form\Element\DateSelect::class,
                              'DateSelect'     => \Laminas\Form\Element\DateSelect::class, 'datetime' => \Laminas\Form\Element\DateTime::class,
                              'dateTime'       => \Laminas\Form\Element\DateTime::class, 'DateTime' => \Laminas\Form\Element\DateTime::class,
                              'datetimelocal'  => \Laminas\Form\Element\DateTimeLocal::class, 'dateTimeLocal' => \Laminas\Form\Element\DateTimeLocal::class,
                              'DateTimeLocal'  => \Laminas\Form\Element\DateTimeLocal::class, 'datetimeselect' => \Laminas\Form\Element\DateTimeSelect::class,
                              'dateTimeSelect' => \Laminas\Form\Element\DateTimeSelect::class, 'DateTimeSelect' => \Laminas\Form\Element\DateTimeSelect::class,
                              'element'        => \Laminas\Form\Element::class, 'Element' => \Laminas\Form\Element::class, 'email' => \Laminas\Form\Element\Email::class,
                              'Email'          => \Laminas\Form\Element\Email::class, 'fieldset' => \Laminas\Form\Fieldset::class, 'Fieldset' => \Laminas\Form\Fieldset::class,
                              'file'           => \Laminas\Form\Element\File::class, 'File' => \Laminas\Form\Element\File::class, 'form' => \Laminas\Form\Form::class,
                              'Form'           => \Laminas\Form\Form::class, 'hidden' => \Laminas\Form\Element\Hidden::class, 'Hidden' => \Laminas\Form\Element\Hidden::class,
                              'image'          => \Laminas\Form\Element\Image::class, 'Image' => \Laminas\Form\Element\Image::class, 'month' => \Laminas\Form\Element\Month::class,
                              'Month'          => \Laminas\Form\Element\Month::class, 'monthselect' => \Laminas\Form\Element\MonthSelect::class,
                              'monthSelect'    => \Laminas\Form\Element\MonthSelect::class, 'MonthSelect' => \Laminas\Form\Element\MonthSelect::class,
                              'multicheckbox'  => \Laminas\Form\Element\MultiCheckbox::class, 'multiCheckbox' => \Laminas\Form\Element\MultiCheckbox::class,
                              'MultiCheckbox'  => \Laminas\Form\Element\MultiCheckbox::class, 'multiCheckBox' => \Laminas\Form\Element\MultiCheckbox::class,
                              'MultiCheckBox'  => \Laminas\Form\Element\MultiCheckbox::class, 'number' => \Laminas\Form\Element\Number::class,
                              'Number'         => \Laminas\Form\Element\Number::class, 'password' => \Laminas\Form\Element\Password::class,
                              'Password'       => \Laminas\Form\Element\Password::class, 'radio' => \Laminas\Form\Element\Radio::class,
                              'Radio'          => \Laminas\Form\Element\Radio::class, 'range' => \Laminas\Form\Element\Range::class, 'Range' => \Laminas\Form\Element\Range::class,
                              'search'         => \Laminas\Form\Element\Search::class, 'Search' => \Laminas\Form\Element\Search::class,
                              'select'         => \Laminas\Form\Element\Select::class, 'Select' => \Laminas\Form\Element\Select::class,
                              'submit'         => \Laminas\Form\Element\Submit::class, 'Submit' => \Laminas\Form\Element\Submit::class, 'tel' => \Laminas\Form\Element\Tel::class,
                              'Tel'            => \Laminas\Form\Element\Tel::class, 'text' => \Laminas\Form\Element\Text::class, 'Text' => \Laminas\Form\Element\Text::class,
                              'textarea'       => \Laminas\Form\Element\Textarea::class, 'Textarea' => \Laminas\Form\Element\Textarea::class,
                              'time'           => \Laminas\Form\Element\Time::class, 'Time' => \Laminas\Form\Element\Time::class, 'url' => \Laminas\Form\Element\Url::class,
                              'Url'            => \Laminas\Form\Element\Url::class, 'week' => \Laminas\Form\Element\Week::class, 'Week' => \Laminas\Form\Element\Week::class];
        /**
         * Factories for default set of helpers
         *
         * @var array
         */
        protected $factories = [
            \Laminas\Form\Element\Button::class         => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Captcha::class        => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Checkbox::class       => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Collection::class     => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Color::class          => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Csrf::class           => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Date::class           => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\DateSelect::class     => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\DateTime::class       => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\DateTimeLocal::class  => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\DateTimeSelect::class => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element::class                => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Email::class          => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Fieldset::class               => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\File::class           => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Form::class                   => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Hidden::class         => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Image::class          => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Month::class          => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\MonthSelect::class    => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\MultiCheckbox::class  => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Number::class         => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Password::class       => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Radio::class          => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Range::class          => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Search::class         => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Select::class         => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Submit::class         => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Tel::class            => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Text::class           => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Textarea::class       => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Time::class           => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Url::class            => \Laminas\Form\ElementFactory::class,
            \Laminas\Form\Element\Week::class           => \Laminas\Form\ElementFactory::class,
            // v2 normalized variants
            'laminasformelementbutton'                  => \Laminas\Form\ElementFactory::class,
            'laminasformelementcaptcha'                 => \Laminas\Form\ElementFactory::class,
            'laminasformelementcheckbox'                => \Laminas\Form\ElementFactory::class,
            'laminasformelementcollection'              => \Laminas\Form\ElementFactory::class,
            'laminasformelementcolor'                   => \Laminas\Form\ElementFactory::class,
            'laminasformelementcsrf'                    => \Laminas\Form\ElementFactory::class,
            'laminasformelementdate'                    => \Laminas\Form\ElementFactory::class,
            'laminasformelementdateselect'              => \Laminas\Form\ElementFactory::class,
            'laminasformelementdatetime'                => \Laminas\Form\ElementFactory::class,
            'laminasformelementdatetimelocal'           => \Laminas\Form\ElementFactory::class,
            'laminasformelementdatetimeselect'          => \Laminas\Form\ElementFactory::class,
            'laminasformelement'                        => \Laminas\Form\ElementFactory::class,
            'laminasformelementemail'                   => \Laminas\Form\ElementFactory::class,
            'laminasformfieldset'                       => \Laminas\Form\ElementFactory::class,
            'laminasformelementfile'                    => \Laminas\Form\ElementFactory::class,
            'laminasformform'                           => \Laminas\Form\ElementFactory::class,
            'laminasformelementhidden'                  => \Laminas\Form\ElementFactory::class,
            'laminasformelementimage'                   => \Laminas\Form\ElementFactory::class,
            'laminasformelementmonth'                   => \Laminas\Form\ElementFactory::class,
            'laminasformelementmonthselect'             => \Laminas\Form\ElementFactory::class,
            'laminasformelementmulticheckbox'           => \Laminas\Form\ElementFactory::class,
            'laminasformelementnumber'                  => \Laminas\Form\ElementFactory::class,
            'laminasformelementpassword'                => \Laminas\Form\ElementFactory::class,
            'laminasformelementradio'                   => \Laminas\Form\ElementFactory::class,
            'laminasformelementrange'                   => \Laminas\Form\ElementFactory::class,
            'laminasformelementsearch'                  => \Laminas\Form\ElementFactory::class,
            'laminasformelementselect'                  => \Laminas\Form\ElementFactory::class,
            'laminasformelementsubmit'                  => \Laminas\Form\ElementFactory::class,
            'laminasformelementtel'                     => \Laminas\Form\ElementFactory::class,
            'laminasformelementtext'                    => \Laminas\Form\ElementFactory::class,
            'laminasformelementtextarea'                => \Laminas\Form\ElementFactory::class,
            'laminasformelementtime'                    => \Laminas\Form\ElementFactory::class,
            'laminasformelementurl'                     => \Laminas\Form\ElementFactory::class,
            'laminasformelementweek'                    => \Laminas\Form\ElementFactory::class,
        ];
        /**
         * Don't share form elements by default (v3)
         *
         * @var bool
         */
        protected $sharedByDefault = false;
        /**
         * Interface all plugins managed by this class must implement.
         *
         * @var class-string
         */
        protected $instanceOf = \Laminas\Form\ElementInterface::class;

        /**
         * Inject the factory to any element that implements FormFactoryAwareInterface
         *
         * @param mixed $instance Instance to inspect and optionally inject.
         */
        public function injectFactory(\Psr\Container\ContainerInterface $container, mixed $instance): void {}

        /**
         * Call init() on any element that implements InitializableInterface
         *
         * @param mixed $instance Instance to inspect and optionally initialize.
         */
        public function callElementInit(\Psr\Container\ContainerInterface $container, mixed $instance): void {}

        /**
         * Override setInvokableClass
         *
         * Overrides setInvokableClass to:
         *
         * - add a factory mapping $invokableClass to ElementFactory::class
         * - alias $name to $invokableClass
         *
         * @param string      $name
         * @param null|string $class
         */
        public function setInvokableClass($name, $class = null): void {}

        /**
         * Validate the plugin is of the expected type (v3).
         *
         * Validates against `$instanceOf`.
         *
         * @param mixed                   $instance
         *
         * @throws \Laminas\ServiceManager\Exception\InvalidServiceException
         * @psalm-assert ElementInterface $instance
         */
        public function validate($instance): void {}

        /**
         * Overrides parent::configure in order to ensure default initializers are in expected positions.
         *
         * Always pushes `injectFactory` to top of initializer stack, and
         * `callElementInit` to the bottom.
         *
         * @inheritDoc
         */
        public function configure(array $config) {}

        /**
         * Retrieve a service from the manager by name
         *
         * Allows passing an array of options to use when creating the instance.
         * createFromInvokable() will use these and pass them to the instance
         * constructor if not null and a non-empty array.
         *
         * @param class-string<ElementInterface>|string $name    Service name of plugin to retrieve.
         * @param null|array<mixed>                     $options Options to use when creating the instance.
         *
         * @psalm-return ($name is class-string<ElementInterface> ? ElementInterface : mixed)
         */
        public function get($name, ?array $options = null): mixed {}

        /**
         * Try to pull hydrator from the creation context, or instantiates it from its name
         *
         * @param string|class-string<\Laminas\Hydrator\HydratorInterface> $hydratorName
         *
         * @return mixed
         * @psalm-return ($hydratorName is class-string<\Laminas\Hydrator\HydratorInterface> ? \Laminas\Hydrator\HydratorInterface : mixed)
         * @throws Exception\DomainException
         */
        public function getHydratorFromName(string $hydratorName) {}

        /**
         * Try to pull factory from the creation context, or instantiates it from its name
         *
         * @return mixed
         * @throws Exception\DomainException
         */
        public function getFactoryFromName(string $factoryName) {}
    }

    trait FormFactoryAwareTrait
    {
        /** @var null|Factory */
        protected $factory;

        /**
         * Compose a form factory into the object
         *
         * @return mixed
         */
        public function setFormFactory(\Laminas\Form\Factory $factory) {}
    }

    /** @psalm-import-type ServiceManagerConfiguration from \Laminas\ServiceManager\ServiceManager */
    final class FormElementManagerFactory implements \Laminas\ServiceManager\Factory\FactoryInterface
    {
        /**
         * @inheritDoc
         *
         * @param string|null                      $requestedName
         * @param ServiceManagerConfiguration|null $options
         *
         * @return \Laminas\ServiceManager\AbstractPluginManager
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null): \Laminas\ServiceManager\AbstractPluginManager {}
    }

    class Form extends \Laminas\Form\Fieldset implements \Laminas\Form\FormInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['method' => 'POST'];
        /**
         * How to bind values to the attached object
         *
         * @var int
         */
        protected $bindAs = \Laminas\Form\FormInterface::VALUES_NORMALIZED;
        /**
         * Whether or not to bind values to the bound object on successful validation
         *
         * @var int
         */
        protected $bindOnValidate = \Laminas\Form\FormInterface::BIND_ON_VALIDATE;
        /**
         * Base fieldset to use for hydrating (if none specified, directly hydrate elements)
         *
         * @var null|FieldsetInterface
         */
        protected $baseFieldset;
        /**
         * Data being validated
         *
         * @var null|array
         */
        protected $data;
        /** @var null|\Laminas\InputFilter\InputFilterInterface */
        protected $filter;
        /**
         * Whether or not to automatically scan for input filter defaults on
         * attached fieldsets and elements
         *
         * @var bool
         */
        protected $useInputFilterDefaults = true;
        /**
         * Has the input filter defaults been added already ?
         *
         * @var bool
         */
        protected $hasAddedInputFilterDefaults = false;
        /**
         * Whether or not validation has occurred
         *
         * @var bool
         */
        protected $hasValidated = false;
        /**
         * Result of last validation operation
         *
         * @var bool
         */
        protected $isValid = false;
        /**
         * Is the form prepared ?
         *
         * @var bool
         */
        protected $isPrepared = false;
        /**
         * Prefer form input filter over input filter defaults
         *
         * @var bool
         */
        protected $preferFormInputFilter = true;
        /**
         * Has preferFormInputFilter been set with setPreferFormInputFilter?
         *
         * @var bool
         */
        protected $hasSetPreferFormInputFilter = false;
        /**
         * Are the form elements/fieldsets wrapped by the form name ?
         *
         * @var bool
         */
        protected $wrapElements = false;
        /**
         * Validation group, if any
         *
         * @var null|array
         */
        protected $validationGroup;

        /**
         * Set options for a form. Accepted options are:
         * - prefer_form_input_filter: is form input filter is preferred?
         *
         * @param iterable $options
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setOptions(iterable $options) {}

        /**
         * Add an element or fieldset
         *
         * If $elementOrFieldset is an array or Traversable, passes the argument on
         * to the composed factory to create the object before attaching it.
         *
         * $flags could contain metadata such as the alias under which to register
         * the element or fieldset, order in which to prioritize it, etc.
         *
         * @param array|\Traversable|ElementInterface $elementOrFieldset
         * @param array                               $flags
         *
         * @return $this
         */
        public function add($elementOrFieldset, array $flags = []) {}

        /**
         * Ensures state is ready for use
         *
         * Marshalls the input filter, to ensure validation error messages are
         * available, and prepares any elements and/or fieldsets that require
         * preparation.
         *
         * @return $this
         */
        public function prepare() {}

        /**
         * Ensures state is ready for use. Here, we append the name of the fieldsets to every elements in order to avoid
         * name clashes if the same fieldset is used multiple times
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}

        /**
         * Set data to validate and/or populate elements
         *
         * Typically, also passes data on to the composed input filter.
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setData(iterable $data) {}

        /**
         * Bind an object to the form
         *
         * Ensures the object is populated with validated values.
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function bind(object $object, int $flags = \Laminas\Form\FormInterface::VALUES_NORMALIZED) {}

        /**
         * Set the hydrator to use when binding an object to the element
         *
         * @return $this
         */
        public function setHydrator(\Laminas\Hydrator\HydratorInterface $hydrator) {}

        /**
         * Bind values to the bound object
         *
         * @param array $values
         */
        public function bindValues(array $values = [], ?array $validationGroup = null): void {}

        /**
         * Parse filtered values and return only posted fields for binding
         *
         * @return array
         */
        protected function prepareBindData(array $values, array $match): array {}

        /**
         * Set flag indicating whether or not to bind values on successful validation
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setBindOnValidate(int $bindOnValidateFlag) {}

        /**
         * Will we bind values to the bound object on successful validation?
         */
        public function bindOnValidate(): bool {}

        /**
         * Set the base fieldset to use when hydrating
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setBaseFieldset(\Laminas\Form\FieldsetInterface $baseFieldset) {}

        /**
         * Get the base fieldset to use when hydrating
         */
        public function getBaseFieldset(): ?\Laminas\Form\FieldsetInterface {}

        /**
         * Check if the form has been validated
         */
        public function hasValidated(): bool {}

        /**
         * Validate the form
         *
         * Typically, will proxy to the composed input filter.
         *
         * @throws Exception\DomainException
         */
        public function isValid(): bool {}

        /**
         * Retrieve the validated data
         *
         * By default, retrieves normalized values; pass one of the
         * FormInterface::VALUES_* constants to shape the behavior.
         *
         * @return array|object
         * @throws Exception\DomainException
         *
         * @psalm-taint-source input
         */
        public function getData(int $flag = \Laminas\Form\FormInterface::VALUES_NORMALIZED) {}

        /**
         * Set the validation group (set of values to validate)
         *
         * Typically, proxies to the composed input filter
         *
         * @return $this
         */
        public function setValidationGroup(array $group) {}

        public function setValidateAll(): void {}

        /**
         * Retrieve the current validation group, if any
         *
         * @return null|array
         */
        public function getValidationGroup(): ?array {}

        /**
         * Prepare the validation group in case Collection elements were used (this function also handle
         * the case where elements could have been dynamically added or removed from a collection using JavaScript)
         */
        protected function prepareValidationGroup(\Laminas\Form\Fieldset $formOrFieldset, array $data, array &$validationGroup): void {}

        /**
         * Set the input filter used by this form
         *
         * @return $this
         */
        public function setInputFilter(\Laminas\InputFilter\InputFilterInterface $inputFilter) {}

        /**
         * Retrieve input filter used by this form
         */
        public function getInputFilter(): \Laminas\InputFilter\InputFilterInterface {}

        /**
         * Set flag indicating whether or not to scan elements and fieldsets for defaults
         *
         * @return $this
         */
        public function setUseInputFilterDefaults(bool $useInputFilterDefaults) {}

        /**
         * Should we use input filter defaults from elements and fieldsets?
         */
        public function useInputFilterDefaults(): bool {}

        /**
         * Set flag indicating whether or not to prefer the form input filter over element and fieldset defaults
         *
         * @return $this
         */
        public function setPreferFormInputFilter(bool $preferFormInputFilter) {}

        /**
         * Should we use form input filter over element input filter defaults from elements and fieldsets?
         */
        public function getPreferFormInputFilter(): bool {}

        /**
         * Attach defaults provided by the elements to the input filter
         *
         * @param FieldsetInterface $fieldset Fieldset to traverse when looking for default inputs
         */
        public function attachInputFilterDefaults(\Laminas\InputFilter\InputFilterInterface $inputFilter, \Laminas\Form\FieldsetInterface $fieldset): void {}

        /**
         * Are the form elements/fieldsets names wrapped by the form name ?
         *
         * @return $this
         */
        public function setWrapElements(bool $wrapElements) {}

        /**
         * If true, form elements/fieldsets name's are wrapped around the form name itself
         */
        public function wrapElements(): bool {}

        /**
         * @inheritDoc
         *
         * @param bool $onlyBase
         */
        public function populateValues(iterable $data, bool $onlyBase = false): void {}

        /**
         * Recursively extract values for elements and sub-fieldsets
         *
         * @return array
         */
        protected function extract(): array {}

        /**
         * Set the input filter by name to use when binding an object to the element.
         *
         * The input filter manager {@see InputFilterPluginManager} is used via the
         * form factory {@see Factory} and the input filter factory
         * {@see \Laminas\InputFilter\Factory} to fetch the input filter.
         */
        public function setInputFilterByName(string $inputFilterName): void {}
    }

    final class FormAbstractServiceFactory implements \Laminas\ServiceManager\Factory\AbstractFactoryInterface
    {
        /**
         * Create a form (v3)
         *
         * @param string     $requestedName
         * @param array|null $options
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null): \Laminas\Form\FormInterface {}

        /**
         * Can we create the requested service? (v3)
         *
         * @param string $requestedName
         */
        public function canCreate(\Psr\Container\ContainerInterface $container, $requestedName): bool {}
    }

    final class Module
    {
        /**
         * Return laminas-form configuration for laminas-mvc application.
         *
         * @return array
         */
        public function getConfig(): array {}

        /**
         * Register a specification for the FormElementManager with the ServiceListener.
         */
        public function init(\Laminas\ModuleManager\ModuleManager $moduleManager): void {}
    }

    /**
     * Factory for instantiating form elements
     */
    final class ElementFactory implements \Laminas\ServiceManager\Factory\FactoryInterface
    {
        /**
         * Create an instance of the requested class name.
         *
         * @param string     $requestedName
         * @param null|array $options
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null): object {}
    }

    trait LabelAwareTrait
    {
        /**
         * Label specific html attributes
         *
         * @var array
         */
        protected $labelAttributes = [];
        /**
         * Label specific options
         *
         * @var array
         */
        protected $labelOptions = [];

        /**
         * Set the attributes to use with the label
         *
         * @return $this
         */
        public function setLabelAttributes(array $labelAttributes) {}

        /**
         * Get the attributes to use with the label
         *
         * @return array
         */
        public function getLabelAttributes(): array {}

        /**
         * Set many label options at once
         *
         * Implementation will decide if this will overwrite or merge.
         *
         * @return $this
         * @throws Exception\InvalidArgumentException
         */
        public function setLabelOptions(iterable $arrayOrTraversable) {}

        /**
         * Get label specific options
         *
         * @return array
         */
        public function getLabelOptions(): array {}

        /**
         * Clear all label options
         *
         * @return $this
         */
        public function clearLabelOptions() {}

        /**
         * Remove many attributes at once
         *
         * @return $this
         */
        public function removeLabelOptions(array $keys) {}

        /**
         * Set a single label optionn
         *
         * @return $this
         */
        public function setLabelOption(string $key, mixed $value) {}

        /**
         * Retrieve a single label option
         *
         * @return mixed|null
         */
        public function getLabelOption(string $key) {}

        /**
         * Remove a single label option
         *
         * @return $this
         */
        public function removeLabelOption(string $key) {}

        /**
         * Does the element has a specific label option ?
         */
        public function hasLabelOption(string $key): bool {}
    }

    class Factory
    {
        /** @var null|\Laminas\InputFilter\Factory */
        protected $inputFilterFactory;
        /** @var null|FormElementManager */
        protected $formElementManager;

        public function __construct(?\Laminas\Form\FormElementManager $formElementManager = null, ?\Laminas\InputFilter\Factory $inputFilterFactory = null) {}

        /**
         * Set input filter factory to use when creating forms
         *
         * @return $this
         */
        public function setInputFilterFactory(\Laminas\InputFilter\Factory $inputFilterFactory) {}

        /**
         * Get current input filter factory
         *
         * If none provided, uses an unconfigured instance.
         */
        public function getInputFilterFactory(): \Laminas\InputFilter\Factory {}

        /**
         * Set the form element manager
         *
         * @return $this
         */
        public function setFormElementManager(\Laminas\Form\FormElementManager $formElementManager) {}

        /**
         * Get form element manager
         */
        public function getFormElementManager(): \Laminas\Form\FormElementManager {}

        /**
         * Create an element, fieldset, or form
         *
         * Introspects the 'type' key of the provided $spec, and determines what
         * type is being requested; if none is provided, assumes the spec
         * represents simply an element.
         *
         * @param array|\Traversable|\ArrayAccess $spec
         *
         * @throws Exception\DomainException
         */
        public function create($spec): \Laminas\Form\ElementInterface {}

        /**
         * Create an element
         */
        public function createElement(array $spec): \Laminas\Form\ElementInterface {}

        /**
         * Create a fieldset
         */
        public function createFieldset(array $spec): \Laminas\Form\FieldsetInterface {}

        /**
         * Create a form
         */
        public function createForm(array $spec): \Laminas\Form\FormInterface {}

        /**
         * Configure an element based on the provided specification
         *
         * Specification can contain any of the following:
         * - type: the Element class to use; defaults to \Laminas\Form\Element
         * - name: what name to provide the element, if any
         * - options: an array or Traversable object of element options
         * - attributes: an array or Traversable object of element attributes to assign
         *
         * @param array|\Traversable|\ArrayAccess $spec
         *
         * @throws Exception\DomainException
         */
        public function configureElement(\Laminas\Form\ElementInterface $element, $spec): \Laminas\Form\ElementInterface {}

        /**
         * Configure a fieldset based on the provided specification
         *
         * Specification can contain any of the following:
         * - type: the Fieldset class to use; defaults to \Laminas\Form\Fieldset
         * - name: what name to provide the fieldset, if any
         * - options: an array, Traversable, or ArrayAccess object of element options
         * - attributes: an array, Traversable, or ArrayAccess object of element
         *   attributes to assign
         * - elements: an array or Traversable object where each entry is an array
         *   or ArrayAccess object containing the keys:
         *   - flags: (optional) array of flags to pass to FieldsetInterface::add()
         *   - spec: the actual element specification, per {@link configureElement()}
         *
         * @param array|\Traversable|\ArrayAccess $spec
         *
         * @throws Exception\DomainException
         */
        public function configureFieldset(\Laminas\Form\FieldsetInterface $fieldset, $spec): \Laminas\Form\FieldsetInterface {}

        /**
         * Configure a form based on the provided specification
         *
         * Specification follows that of {@link configureFieldset()}, and adds the
         * following keys:
         *
         * - input_filter: input filter instance, named input filter class, or
         *   array specification for the input filter factory
         * - hydrator: hydrator instance or named hydrator class
         *
         * @param array|\Traversable|\ArrayAccess $spec
         */
        public function configureForm(\Laminas\Form\FormInterface $form, $spec): \Laminas\Form\FormInterface {}

        /**
         * Validate a provided specification
         *
         * Ensures we have an array, Traversable, or ArrayAccess object, and returns it.
         *
         * @param array|\Traversable|\ArrayAccess $spec
         * @param string                          $method Method invoking the validator
         *
         * @return array|\ArrayAccess
         * @throws Exception\InvalidArgumentException For invalid $spec.
         */
        protected function validateSpecification($spec, string $method) {}

        /**
         * Takes a list of element specifications, creates the elements, and injects them into the provided fieldset
         *
         * @param array|\Traversable|\ArrayAccess $elements
         * @param string                          $method Method invoking this one (for exception messages)
         */
        protected function prepareAndInjectElements($elements, \Laminas\Form\FieldsetInterface $fieldset, string $method): void {}

        /**
         * Takes a list of fieldset specifications, creates the fieldsets, and injects them into the master fieldset
         *
         * @param array|\Traversable|\ArrayAccess $fieldsets
         * @param string                          $method Method invoking this one (for exception messages)
         */
        public function prepareAndInjectFieldsets($fieldsets, \Laminas\Form\FieldsetInterface $masterFieldset, string $method): void {}

        /**
         * Prepare and inject an object
         *
         * Takes a string indicating a class name, instantiates the class
         * by that name, and injects the class instance as the bound object.
         *
         * @throws Exception\DomainException
         */
        protected function prepareAndInjectObject(string $objectName, \Laminas\Form\FieldsetInterface $fieldset, string $method): void {}

        /**
         * Prepare and inject a named hydrator
         *
         * Takes a string indicating a hydrator class name (or a concrete instance), try first to instantiates the class
         * by pulling it from service manager, and injects the hydrator instance into the form.
         *
         * @param string|array|\Laminas\Hydrator\HydratorInterface $hydratorOrName
         *
         * @throws Exception\DomainException If $hydratorOrName is not a string, does not resolve to a known class, or
         *                                   the class does not implement Hydrator\HydratorInterface.
         */
        protected function prepareAndInjectHydrator($hydratorOrName, \Laminas\Form\FieldsetInterface $fieldset, string $method): void {}

        /**
         * Prepare and inject a named factory
         *
         * Takes a string indicating a factory class name (or a concrete instance), try first to instantiates the class
         * by pulling it from service manager, and injects the factory instance into the fieldset.
         *
         * @param string|array|Factory $factoryOrName
         *
         * @throws Exception\DomainException If $factoryOrName is not a string, does not resolve to a known class, or
         *                                   the class does not extend Form\Factory.
         */
        protected function prepareAndInjectFactory($factoryOrName, \Laminas\Form\FieldsetInterface $fieldset, string $method): void {}

        /**
         * Prepare an input filter instance and inject in the provided form
         *
         * If the input filter specified is a string, assumes it is a class name,
         * and attempts to instantiate it. If the class does not exist, or does
         * not extend InputFilterInterface, an exception is raised.
         *
         * Otherwise, $spec is passed on to the attached InputFilter Factory
         * instance in order to create the input filter.
         *
         * @param string|array|\Traversable $spec
         *
         * @throws Exception\DomainException For unknown InputFilter class or invalid InputFilter instance.
         */
        protected function prepareAndInjectInputFilter($spec, \Laminas\Form\FormInterface $form, string $method): void {}
    }

    /** @psalm-import-type ServiceManagerConfigurationType from \Laminas\ServiceManager\ConfigInterface */
    final class ConfigProvider
    {
        /**
         * Return general-purpose laminas-i18n configuration.
         *
         * @return array{
         *     dependencies: ServiceManagerConfigurationType,
         *     view_helpers: ServiceManagerConfigurationType,
         *     ...
         * }
         */
        public function __invoke(): array {}

        /**
         * Return application-level dependency configuration.
         *
         * @return ServiceManagerConfigurationType
         */
        public function getDependencyConfig(): array {}

        /**
         * Return laminas-form helper configuration.
         *
         * Obsoletes View\HelperConfig.
         *
         * @return ServiceManagerConfigurationType
         */
        public function getViewHelperConfig(): array {}
    }
}

namespace Laminas\Form\Element {
    class Select extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'select'];
        /** @var null|\Laminas\Validator\ValidatorInterface */
        protected $validator;
        /** @var bool */
        protected $disableInArrayValidator = false;
        /**
         * Create an empty option (option with label but no value). If set to null, no option is created
         *
         * @var null|string|array
         */
        protected $emptyOption;
        /** @var array */
        protected $valueOptions = [];
        /** @var bool */
        protected $useHiddenElement = false;
        /** @var string */
        protected $unselectedValue = '';

        /**
         * @return array
         */
        public function getValueOptions(): array {}

        /**
         * @return $this
         */
        public function setValueOptions(array $options) {}

        /**
         * @return $this
         */
        public function unsetValueOption(string $key) {}

        /**
         * Set options for an element. Accepted options are:
         * - label: label to associate with the element
         * - label_attributes: attributes to use when the label is rendered
         * - value_options: list of values and labels for the select options
         * - empty_option: should an empty option be prepended to the options ?
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setOptions(iterable $options) {}

        /**
         * Set a single element attribute
         *
         * @param mixed $value
         *
         * @return $this
         */
        public function setAttribute(string $key, $value) {}

        /**
         * Set the flag to allow for disabling the automatic addition of an InArray validator.
         *
         * @return $this
         */
        public function setDisableInArrayValidator(bool $disableOption) {}

        /**
         * Get the disable in array validator flag.
         */
        public function disableInArrayValidator(): bool {}

        /**
         * Set the string for an empty option (can be empty string). If set to null, no option will be added
         *
         * @param null|string|array $emptyOption
         *
         * @return $this
         */
        public function setEmptyOption($emptyOption) {}

        /**
         * Return the string for the empty option (null if none)
         *
         * @return null|string|array
         */
        public function getEmptyOption() {}

        /**
         * Get validator
         */
        protected function getValidator(): ?\Laminas\Validator\ValidatorInterface {}

        /**
         * Do we render hidden element?
         *
         * @return $this
         */
        public function setUseHiddenElement(bool $useHiddenElement) {}

        /**
         * Do we render hidden element?
         */
        public function useHiddenElement(): bool {}

        /**
         * Set the value if the select is not selected
         *
         * @return $this
         */
        public function setUnselectedValue(string $unselectedValue) {}

        /**
         * Get the value when the select is not selected
         */
        public function getUnselectedValue(): string {}

        /**
         * Provide default input rules for this element
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}

        /**
         * Get only the values from the options attribute
         *
         * @return array
         */
        protected function getValueOptionsValues(): array {}

        /**
         * @return mixed
         */
        protected function getOptionValue(mixed $key, mixed $optionSpec) {}

        /**
         * Element has the multiple attribute
         */
        public function isMultiple(): bool {}
    }

    abstract class AbstractDateTime extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /**
         * A valid format string accepted by date()
         *
         * @var string
         */
        protected $format = 'Y-m-d\\TH:iP';
        /** @var array<\Laminas\Validator\ValidatorInterface> */
        protected $validators = [];

        /**
         * Accepted options for DateTime:
         * - format: A \DateTime compatible string
         *
         * @return $this
         */
        public function setOptions(iterable $options) {}

        /**
         * Retrieve the element value
         *
         * If the value is instance of DateTimeInterface, and $returnFormattedValue
         * is true (the default), we return the string representation using the
         * currently registered format.
         *
         * If $returnFormattedValue is false, the original value will be
         * returned, regardless of type.
         *
         * @return mixed
         */
        public function getValue(bool $returnFormattedValue = true) {}

        /**
         * Set value for format
         *
         * @return $this
         */
        public function setFormat(string $format) {}

        /**
         * Retrieve the DateTime format to use for the value
         */
        public function getFormat(): string {}

        /**
         * Get validators
         *
         * @return array<\Laminas\Validator\ValidatorInterface>
         */
        protected function getValidators(): array {}

        /**
         * Retrieves a Date Validator configured for a DateTime Input type
         */
        protected function getDateValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Retrieves a DateStep Validator configured for a DateTime Input type
         */
        protected function getStepValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Provide default input rules for this element
         *
         * Attaches default validators for the datetime input.
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}
    }

    class Month extends \Laminas\Form\Element\AbstractDateTime
    {
        /**
         * A valid format string accepted by date()
         *
         * @var string
         */
        protected $format = '!Y-m';
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'month'];

        /**
         * Retrieves a Date Validator configured for a Month Input type
         */
        protected function getDateValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Retrieves a DateStep Validator configured for a Month Input type
         */
        protected function getStepValidator(): \Laminas\Validator\ValidatorInterface {}
    }

    class Textarea extends \Laminas\Form\Element
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'textarea'];
    }

    class Checkbox extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'checkbox'];
        /** @var null|\Laminas\Validator\ValidatorInterface */
        protected $validator;
        /** @var bool */
        protected $useHiddenElement = true;
        /** @var string */
        protected $uncheckedValue = '0';
        /** @var string */
        protected $checkedValue = '1';

        /**
         * Accepted options for MultiCheckbox:
         * - use_hidden_element: do we render hidden element?
         * - unchecked_value: value for checkbox when unchecked
         * - checked_value: value for checkbox when checked
         *
         * @return $this
         */
        public function setOptions(iterable $options) {}

        /**
         * Do we render hidden element?
         *
         * @return $this
         */
        public function setUseHiddenElement(bool $useHiddenElement) {}

        /**
         * Do we render hidden element?
         */
        public function useHiddenElement(): bool {}

        /**
         * Set the value to use when checkbox is unchecked
         *
         * @return $this
         */
        public function setUncheckedValue(string $uncheckedValue) {}

        /**
         * Get the value to use when checkbox is unchecked
         */
        public function getUncheckedValue(): string {}

        /**
         * Set the value to use when checkbox is checked
         *
         * @return $this
         */
        public function setCheckedValue(string $checkedValue) {}

        /**
         * Get the value to use when checkbox is checked
         */
        public function getCheckedValue(): string {}

        /**
         * Get validator
         */
        protected function getValidator(): ?\Laminas\Validator\ValidatorInterface {}

        /**
         * Provide default input rules for this element
         *
         * Attaches the captcha as a validator.
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}

        /**
         * Checks if this checkbox is checked.
         */
        public function isChecked(): bool {}

        /**
         * Checks or unchecks the checkbox.
         *
         * @param bool $value The flag to set.
         *
         * @return $this
         */
        public function setChecked(bool $value) {}

        /**
         * Checks or unchecks the checkbox.
         *
         * @param mixed $value A boolean flag or string that is checked against the "checked value".
         *
         * @return $this
         */
        public function setValue($value) {}
    }

    class MultiCheckbox extends \Laminas\Form\Element\Checkbox
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'multi_checkbox'];
        /** @var bool */
        protected $disableInArrayValidator = false;
        /** @var bool */
        protected $useHiddenElement = false;
        /** @var string */
        protected $uncheckedValue = '';
        /** @var array */
        protected $valueOptions = [];

        /**
         * @return array
         */
        public function getValueOptions(): array {}

        /**
         * @return $this
         */
        public function setValueOptions(array $options) {}

        /**
         * @return $this
         */
        public function unsetValueOption(string $key) {}

        /**
         * Set options for an element. Accepted options are:
         * - label: label to associate with the element
         * - label_attributes: attributes to use when the label is rendered
         * - value_options: list of values and labels for the select options
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setOptions(iterable $options) {}

        /**
         * Set a single element attribute
         *
         * @param mixed $value
         *
         * @return $this
         */
        public function setAttribute(string $key, $value) {}

        /**
         * Set the flag to allow for disabling the automatic addition of an InArray validator.
         *
         * @return $this
         */
        public function setDisableInArrayValidator(bool $disableOption) {}

        /**
         * Get the disable in array validator flag.
         */
        public function disableInArrayValidator(): bool {}

        /**
         * Get validator
         */
        protected function getValidator(): ?\Laminas\Validator\ValidatorInterface {}

        /**
         * Get only the values from the options attribute
         *
         * @return array
         */
        protected function getValueOptionsValues(): array {}

        /**
         * Sets the value that should be selected.
         *
         * @param mixed $value The value to set.
         *
         * @return $this
         */
        public function setValue($value) {}
    }

    class Number extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'number'];
        /** @var array */
        protected $validators = [];

        /**
         * Get validator
         *
         * @return \Laminas\Validator\ValidatorInterface[]
         */
        protected function getValidators(): array {}

        /**
         * Provide default input rules for this element
         *
         * Attaches a number validator, as well as a greater than and less than validators
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}
    }

    class Range extends \Laminas\Form\Element\Number
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'range'];

        /**
         * Get validator
         *
         * @return \Laminas\Validator\ValidatorInterface[]
         */
        protected function getValidators(): array {}
    }

    class Week extends \Laminas\Form\Element\AbstractDateTime
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'week'];

        /**
         * Retrieves a Date Validator configured for a Week Input type
         */
        protected function getDateValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Retrieves a DateStep Validator configured for a Week Input type
         */
        protected function getStepValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * @see https://bugs.php.net/bug.php?id=74511
         *
         * @return array<\Laminas\Validator\ValidatorInterface>
         */
        protected function getValidators(): array {}
    }

    class Submit extends \Laminas\Form\Element
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'submit'];
    }

    class Tel extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'tel'];
        /** @var null|\Laminas\Validator\ValidatorInterface */
        protected $validator;

        /**
         * Get validator
         */
        protected function getValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Provide default input rules for this element
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}
    }

    class Hidden extends \Laminas\Form\Element
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'hidden'];
    }

    class Button extends \Laminas\Form\Element
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'button'];
    }

    class Text extends \Laminas\Form\Element
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'text'];
    }

    class Csrf extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface, \Laminas\Form\ElementPrepareAwareInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'hidden'];
        /** @var array */
        protected $csrfValidatorOptions = [];
        /** @var null|\Laminas\Validator\Csrf */
        protected $csrfValidator;

        /**
         * Accepted options for Csrf:
         * - csrf_options: an array used in the Csrf
         *
         * @return $this
         */
        public function setOptions(iterable $options) {}

        /**
         * @return array
         */
        public function getCsrfValidatorOptions(): array {}

        /**
         * @return $this
         */
        public function setCsrfValidatorOptions(array $options) {}

        /**
         * Get CSRF validator
         */
        public function getCsrfValidator(): \Laminas\Validator\Csrf {}

        /**
         * @return $this
         */
        public function setCsrfValidator(\Laminas\Validator\Csrf $validator) {}

        /**
         * Retrieve value
         *
         * Retrieves the hash from the validator
         */
        public function getValue(): string {}

        /**
         * Override: get attributes
         *
         * Seeds 'value' attribute with validator hash
         */
        public function getAttributes(): array {}

        /**
         * Provide default input rules for this element
         *
         * Attaches the captcha as a validator.
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}

        /**
         * Prepare the form element
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}
    }

    class Captcha extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /** @var null|\Laminas\Captcha\AdapterInterface */
        protected $captcha;

        /**
         * Accepted options for Captcha:
         * - captcha: a valid Laminas\Captcha\AdapterInterface
         *
         * @return $this
         */
        public function setOptions(iterable $options) {}

        /**
         * Set captcha
         *
         * @param iterable<string, mixed>|\Laminas\Captcha\AdapterInterface $captcha
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setCaptcha($captcha) {}

        /**
         * Retrieve captcha (if any)
         */
        public function getCaptcha(): ?\Laminas\Captcha\AdapterInterface {}

        /**
         * Provide default input rules for this element
         *
         * Attaches the captcha as a validator.
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}
    }

    class Date extends \Laminas\Form\Element\AbstractDateTime
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'date'];
        /**
         * Date format to use for DateTime values. By default, this is RFC-3339,
         * full-date (Y-m-d), which is what HTML5 dictates.
         *
         * @var string
         */
        protected $format = 'Y-m-d';

        /**
         * Retrieves a DateStep Validator configured for a Date Input type
         */
        protected function getStepValidator(): \Laminas\Validator\ValidatorInterface {}
    }

    class Email extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'email'];
        /** @var null|\Laminas\Validator\ValidatorInterface */
        protected $validator;
        /** @var null|\Laminas\Validator\ValidatorInterface */
        protected $emailValidator;

        /**
         * Get primary validator
         */
        public function getValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Sets the primary validator to use for this element
         *
         * @return $this
         */
        public function setValidator(\Laminas\Validator\ValidatorInterface $validator) {}

        /**
         * Get the email validator to use for multiple or single
         * email addresses.
         *
         * Note from the HTML5 Specs regarding the regex:
         *
         * "This requirement is a *willful* violation of RFC 5322, which
         * defines a syntax for e-mail addresses that is simultaneously
         * too strict (before the "@" character), too vague
         * (after the "@" character), and too lax (allowing comments,
         * whitespace characters, and quoted strings in manners
         * unfamiliar to most users) to be of practical use here."
         *
         * The default Regex validator is in use to match that of the
         * browser validation, but you are free to set a different
         * (more strict) email validator such as Laminas\Validator\Email
         * if you wish.
         */
        public function getEmailValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Sets the email validator to use for multiple or single
         * email addresses.
         *
         * @return $this
         */
        public function setEmailValidator(\Laminas\Validator\ValidatorInterface $validator) {}

        /**
         * Provide default input rules for this element
         *
         * Attaches an email validator.
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}
    }

    /**
     * @deprecated 3.0.0 This element is deprecated starting with 3.0.0 as it has been removed from WHATWG HTML
     *
     * @see        https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime
     */
    class DateTime extends \Laminas\Form\Element\AbstractDateTime
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'datetime'];
    }

    class MonthSelect extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface, \Laminas\Form\ElementPrepareAwareInterface
    {
        /**
         * Select form element that contains values for month
         *
         * @var Select
         */
        protected $monthElement;
        /**
         * Select form element that contains values for year
         *
         * @var Select
         */
        protected $yearElement;
        /**
         * Min year to use for the select (default: current year - 100)
         *
         * @var int
         */
        protected $minYear;
        /**
         * Max year to use for the select (default: current year)
         *
         * @var int
         */
        protected $maxYear;
        /**
         * If set to true, it will generate an empty option for every select (this is mainly needed by most JavaScript
         * libraries to allow to have a placeholder)
         *
         * @var bool
         */
        protected $createEmptyOption = false;
        /**
         * If set to true, view helpers will render delimiters between <select> elements, according to the
         * specified locale
         *
         * @var bool
         */
        protected $renderDelimiters = true;
        /** @var null|\Laminas\Validator\ValidatorInterface */
        protected $validator;

        /**
         * Constructor. Add two selects elements
         *
         * @param null|int|string $name    Optional name for the element
         * @param iterable        $options Optional options for the element
         */
        public function __construct($name = null, iterable $options = []) {}

        /**
         * Set element options.
         *
         * Accepted options for MonthSelect:
         *
         * - month_attributes: HTML attributes to be rendered with the month element
         * - year_attributes: HTML attributes to be rendered with the month element
         * - min_year: min year to use in the year select
         * - max_year: max year to use in the year select
         *
         * @return $this
         */
        public function setOptions(iterable $options) {}

        public function getMonthElement(): \Laminas\Form\Element\Select {}

        public function getYearElement(): \Laminas\Form\Element\Select {}

        /**
         * Get both the year and month elements
         *
         * @return array
         */
        public function getElements(): array {}

        /**
         * Set the month attributes
         *
         * @return $this
         */
        public function setMonthAttributes(array $monthAttributes) {}

        /**
         * Get the month attributes
         *
         * @return array
         */
        public function getMonthAttributes(): array {}

        /**
         * Set the year attributes
         *
         * @return $this
         */
        public function setYearAttributes(array $yearAttributes) {}

        /**
         * Get the year attributes
         *
         * @return array
         */
        public function getYearAttributes(): array {}

        /**
         * @return $this
         */
        public function setMinYear(int $minYear) {}

        public function getMinYear(): int {}

        /**
         * @return $this
         */
        public function setMaxYear(int $maxYear) {}

        public function getMaxYear(): int {}

        /**
         * @return $this
         */
        public function setShouldCreateEmptyOption(bool $createEmptyOption) {}

        public function shouldCreateEmptyOption(): bool {}

        /**
         * @return $this
         */
        public function setShouldRenderDelimiters(bool $renderDelimiters) {}

        public function shouldRenderDelimiters(): bool {}

        /**
         * @param \DateTime|iterable|string|null|mixed $value
         *
         * @return $this
         */
        public function setValue($value) {}

        public function getValue(): ?string {}

        /**
         * Prepare the form element (mostly used for rendering purposes)
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}

        /**
         * Get validator
         */
        protected function getValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * @inheritDoc
         */
        public function getInputSpecification(): array {}

        /**
         * Clone the element (this is needed by Collection element, as it needs different copies of the elements)
         */
        public function __clone() {}
    }

    class DateSelect extends \Laminas\Form\Element\MonthSelect
    {
        /**
         * Select form element that contains values for day
         *
         * @var Select
         */
        protected $dayElement;

        /**
         * Constructor. Add the day select element
         *
         * @param null|int|string $name    Optional name for the element
         * @param iterable        $options Optional options for the element
         */
        public function __construct($name = null, iterable $options = []) {}

        /**
         * Accepted options for DateSelect (plus the ones from MonthSelect) :
         * - day_attributes: HTML attributes to be rendered with the day element
         *
         * @return $this
         */
        public function setOptions(iterable $options) {}

        public function getDayElement(): \Laminas\Form\Element\Select {}

        /**
         * Get both the year and month elements
         *
         * @return array
         */
        public function getElements(): array {}

        /**
         * Set the day attributes
         *
         * @return $this
         */
        public function setDayAttributes(array $dayAttributes) {}

        /**
         * Get the day attributes
         *
         * @return array
         */
        public function getDayAttributes(): array {}

        /**
         * @param \DateTime|iterable|string|null|mixed $value
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setValue($value) {}

        public function getValue(): ?string {}

        /**
         * Prepare the form element (mostly used for rendering purposes)
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}

        /**
         * Get validator
         */
        protected function getValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * @inheritDoc
         */
        public function getInputSpecification(): array {}

        /**
         * Clone the element (this is needed by Collection element, as it needs different copies of the elements)
         */
        public function __clone() {}
    }

    class DateTimeSelect extends \Laminas\Form\Element\DateSelect
    {
        /**
         * Select form element that contains values for hour
         *
         * @var Select
         */
        protected $hourElement;
        /**
         * Select form element that contains values for minute
         *
         * @var Select
         */
        protected $minuteElement;
        /**
         * Select form element that contains values for second
         *
         * @var Select
         */
        protected $secondElement;
        /**
         * Is the seconds select shown when the element is rendered?
         *
         * @var bool
         */
        protected $shouldShowSeconds = false;

        /**
         * Constructor. Add the hour, minute and second select elements
         *
         * @param null|int|string $name    Optional name for the element
         * @param array           $options Optional options for the element
         */
        public function __construct($name = null, array $options = []) {}

        /**
         * Set options for DateTimeSelect element.
         *
         * Accepted options for DateTimeSelect (plus the ones from DateSelect):
         *
         * - hour_attributes: HTML attributes to be rendered with the hour element
         * - minute_attributes: HTML attributes to be rendered with the minute element
         * - second_attributes: HTML attributes to be rendered with the second element
         * - should_show_seconds: if set to true, the seconds select is shown
         *
         * @return $this
         */
        public function setOptions(iterable $options) {}

        public function getHourElement(): \Laminas\Form\Element\Select {}

        public function getMinuteElement(): \Laminas\Form\Element\Select {}

        public function getSecondElement(): \Laminas\Form\Element\Select {}

        public function getElements(): array {}

        /**
         * Set the hour attributes
         *
         * @return $this
         */
        public function setHourAttributes(array $hourAttributes) {}

        /**
         * Get the hour attributes
         *
         * @return array
         */
        public function getHourAttributes(): array {}

        /**
         * Set the minute attributes
         *
         * @return $this
         */
        public function setMinuteAttributes(array $minuteAttributes) {}

        /**
         * Get the minute attributes
         *
         * @return array
         */
        public function getMinuteAttributes(): array {}

        /**
         * Set the second attributes
         *
         * @return $this
         */
        public function setSecondAttributes(array $secondAttributes) {}

        /**
         * Get the second attributes
         *
         * @return array
         */
        public function getSecondAttributes(): array {}

        /**
         * If set to true, this indicate that the second select is shown. If set to true, the seconds will be
         * assumed to always be 00
         *
         * @return $this
         */
        public function setShouldShowSeconds(bool $shouldShowSeconds) {}

        public function shouldShowSeconds(): bool {}

        /**
         * @param \DateTime|iterable|string|null|mixed $value
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setValue($value) {}

        public function getValue(): ?string {}

        /**
         * Prepare the form element (mostly used for rendering purposes)
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}

        /**
         * Get validator
         */
        protected function getValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * @inheritDoc
         */
        public function getInputSpecification(): array {}

        /**
         * Clone the element (this is needed by Collection element, as it needs different copies of the elements)
         */
        public function __clone() {}
    }

    class DateTimeLocal extends \Laminas\Form\Element\AbstractDateTime
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'datetime-local'];
        /** @inheritDoc */
        protected $format = 'Y-m-d\\TH:i';

        /**
         * Retrieves a DateStepValidator configured for a Date Input type
         */
        protected function getStepValidator(): \Laminas\Validator\ValidatorInterface {}
    }

    class Password extends \Laminas\Form\Element implements \Laminas\Form\ElementPrepareAwareInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'password'];

        /**
         * Remove the password before rendering if the form fails in order to avoid any security issue
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}
    }

    class Radio extends \Laminas\Form\Element\MultiCheckbox
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'radio'];

        /**
         * Get validator
         */
        protected function getValidator(): ?\Laminas\Validator\ValidatorInterface {}
    }

    class Collection extends \Laminas\Form\Fieldset
    {
        /**
         * Default template placeholder
         */
        public const DEFAULT_TEMPLATE_PLACEHOLDER = '__index__';
        /** @var array */
        protected $object;
        /**
         * Element used in the collection
         *
         * @var null|\Laminas\Form\ElementInterface
         */
        protected $targetElement;
        /**
         * Initial count of target element
         *
         * @var int
         */
        protected $count = 1;
        /**
         * Are new elements allowed to be added dynamically ?
         *
         * @var bool
         */
        protected $allowAdd = true;
        /**
         * Are existing elements allowed to be removed dynamically ?
         *
         * @var bool
         */
        protected $allowRemove = true;
        /**
         * Is the template generated ?
         *
         * @var bool
         */
        protected $shouldCreateTemplate = false;
        /**
         * Placeholder used in template content for making your life easier with JavaScript
         *
         * @var string
         */
        protected $templatePlaceholder = self::DEFAULT_TEMPLATE_PLACEHOLDER;
        /**
         * Whether or not to create new objects during modify
         *
         * @var bool
         */
        protected $createNewObjects = false;
        /**
         * Element used as a template
         *
         * @var null|\Laminas\Form\ElementInterface|\Laminas\Form\FieldsetInterface
         */
        protected $templateElement;
        /**
         * The index of the last child element or fieldset
         *
         * @var int
         */
        protected $lastChildIndex = -1;
        /**
         * Should child elements must be created on self::prepareElement()?
         *
         * @var bool
         */
        protected $shouldCreateChildrenOnPrepareElement = true;

        /**
         * Accepted options for Collection:
         * - target_element: an array or element used in the collection
         * - count: number of times the element is added initially
         * - allow_add: if set to true, elements can be added to the form dynamically (using JavaScript)
         * - allow_remove: if set to true, elements can be removed to the form
         * - should_create_template: if set to true, a template is generated (inside a <span>)
         * - template_placeholder: placeholder used in the data template
         *
         * @return $this
         */
        public function setOptions(iterable $options) {}

        /**
         * Checks if the object can be set in this fieldset
         *
         * @param object|array $object
         */
        public function allowObjectBinding($object): bool {}

        /**
         * Set the object used by the hydrator
         * In this case the "object" is a collection of objects
         *
         * @param iterable $object
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setObject($object) {}

        /**
         * Populate values
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function populateValues(iterable $data): void {}

        /**
         * Checks if this fieldset can bind data
         */
        public function allowValueBinding(): bool {}

        /**
         * Bind values to the object
         *
         * @param array $values
         * @param array $validationGroup
         *
         * @return array|mixed|void
         */
        public function bindValues(array $values = [], ?array $validationGroup = null) {}

        /**
         * Set the initial count of target element
         *
         * @return $this
         */
        public function setCount(int $count) {}

        /**
         * Get the initial count of target element
         */
        public function getCount(): int {}

        /**
         * Set the target element
         *
         * @param \Laminas\Form\ElementInterface|array|\Traversable $elementOrFieldset
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setTargetElement($elementOrFieldset) {}

        /**
         * Get target element
         */
        public function getTargetElement(): ?\Laminas\Form\ElementInterface {}

        /**
         * Get allow add
         *
         * @return $this
         */
        public function setAllowAdd(bool $allowAdd) {}

        /**
         * Get allow add
         */
        public function allowAdd(): bool {}

        /**
         * @return $this
         */
        public function setAllowRemove(bool $allowRemove) {}

        public function allowRemove(): bool {}

        /**
         * If set to true, a template prototype is automatically added to the form
         * to ease the creation of dynamic elements through JavaScript
         *
         * @return $this
         */
        public function setShouldCreateTemplate(bool $shouldCreateTemplate) {}

        /**
         * Get if the collection should create a template
         */
        public function shouldCreateTemplate(): bool {}

        /**
         * Set the placeholder used in the template generated to help create new elements in JavaScript
         *
         * @return $this
         */
        public function setTemplatePlaceholder(string $templatePlaceholder) {}

        /**
         * Get the template placeholder
         */
        public function getTemplatePlaceholder(): string {}

        /**
         * @return $this
         */
        public function setCreateNewObjects(bool $createNewObjects) {}

        public function createNewObjects(): bool {}

        /**
         * Get a template element used for rendering purposes only
         *
         * @return null|\Laminas\Form\ElementInterface|\Laminas\Form\FieldsetInterface
         */
        public function getTemplateElement() {}

        /**
         * Prepare the collection by adding a dummy template element if the user want one
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}

        /**
         * @return array
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Stdlib\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         * @throws \Laminas\Form\Exception\InvalidElementException
         */
        public function extract(): array {}

        /**
         * Create a new instance of the target element
         */
        protected function createNewTargetElementInstance(): \Laminas\Form\ElementInterface {}

        /**
         * Add a new instance of the target element
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        protected function addNewTargetElementInstance(string $name): \Laminas\Form\ElementInterface {}

        /**
         * Create a dummy template element
         *
         * @return null|\Laminas\Form\ElementInterface|\Laminas\Form\FieldsetInterface
         */
        protected function createTemplateElement() {}

        /**
         * Replaces the default template object of a sub element with the corresponding
         * real entity so that all properties are preserved.
         */
        protected function replaceTemplateObjects(): void {}
    }

    class Search extends \Laminas\Form\Element
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'search'];
    }

    class Time extends \Laminas\Form\Element\AbstractDateTime
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'time'];
        /**
         * Default date format
         *
         * @var string
         */
        protected $format = 'H:i:s';

        /**
         * Retrieves a DateStepValidator configured for a Date Input type
         */
        protected function getStepValidator(): \Laminas\Validator\ValidatorInterface {}
    }

    class Url extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'url'];
        /** @var null|\Laminas\Validator\ValidatorInterface */
        protected $validator;

        /**
         * Get validator
         */
        public function getValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Provide default input rules for this element
         *
         * Attaches an uri validator.
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}
    }

    class File extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface, \Laminas\Form\ElementPrepareAwareInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'file'];

        /**
         * Prepare the form element (mostly used for rendering purposes)
         */
        public function prepareElement(\Laminas\Form\FormInterface $form): void {}

        /**
         * @inheritDoc
         */
        public function getInputSpecification(): array {}
    }

    class Image extends \Laminas\Form\Element
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'image'];
    }

    class Color extends \Laminas\Form\Element implements \Laminas\InputFilter\InputProviderInterface
    {
        /**
         * Seed attributes
         *
         * @var array
         */
        protected $attributes = ['type' => 'color'];
        /** @var null|\Laminas\Validator\ValidatorInterface */
        protected $validator;

        /**
         * Get validator
         */
        protected function getValidator(): \Laminas\Validator\ValidatorInterface {}

        /**
         * Provide default input rules for this element
         *
         * Attaches a color validator.
         *
         * @inheritDoc
         */
        public function getInputSpecification(): array {}
    }
}

namespace Laminas\Form\Annotation {

    /**
     * ContinueIfEmpty annotation
     *
     * Presence of this annotation is a hint that the associated
     * \Laminas\InputFilter\Input should enable the continueIfEmpty flag.
     *
     * @deprecated 2.4.8 Use `@Validator({"name":"NotEmpty"})` instead.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class ContinueIfEmpty
    {
        /**
         * Receive and process the contents of an annotation
         *
         * @param bool|string $continueIfEmpty
         */
        public function __construct($continueIfEmpty = true) {}

        /**
         * Get value of required flag
         */
        public function getContinueIfEmpty(): bool {}
    }

    /**
     * InputFilter annotation
     *
     * Use this annotation to specify a specific input filter class to use with the
     * form. The value should be a string indicating the fully qualified class name
     * of the input filter to use.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class InputFilter
    {
        /**
         * Receive and process the contents of an annotation
         *
         * @param string|array $inputFilter
         */
        public function __construct($inputFilter) {}

        /**
         * Retrieve the input filter class
         *
         * @return array|string
         */
        public function getInputFilter() {}
    }

    /**
     * Creates a form and input-filters from an array-based form specification
     */
    abstract class AbstractBuilder implements \Laminas\EventManager\EventManagerAwareInterface, \Laminas\Form\FormFactoryAwareInterface
    {
        /** @var null|\Laminas\EventManager\EventManagerInterface */
        protected $eventManager;
        /** @var null|\Laminas\Form\Factory */
        protected $formFactory;
        /** @var null|class-string|object */
        protected $entity;
        /** @var bool */
        protected $preserveDefinedOrder = false;

        /**
         * Set form factory to use when building form from annotations
         *
         * @return $this
         */
        public function setFormFactory(\Laminas\Form\Factory $formFactory) {}

        /**
         * Set event manager instance
         */
        public function setEventManager(\Laminas\EventManager\EventManagerInterface $eventManager): void {}

        /**
         * Retrieve form factory
         *
         * Lazy-loads the default form factory if none is currently set.
         */
        public function getFormFactory(): \Laminas\Form\Factory {}

        /**
         * Get event manager
         */
        public function getEventManager(): \Laminas\EventManager\EventManagerInterface {}

        /**
         * Creates and returns a form specification for use with a factory
         *
         * @param class-string|object $entity Either an instance or a valid class name for an entity
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException If $entity is not an object or class name.
         */
        public function getFormSpecification($entity): \ArrayObject {}

        /**
         * Implementation of deriving a form specification from an entity
         *
         * Must return an array with two elements, where the first element is the form specification and the
         * second element is the input filter specification.
         *
         * @param class-string|object $entity
         *
         * @return array
         */
        protected abstract function getFormSpecificationInternal($entity): array;

        /**
         * Create a form from an object.
         *
         * @param class-string|object $entity
         */
        public function createForm($entity): \Laminas\Form\FormInterface {}

        /**
         * Get the entity used to construct the form.
         *
         * @return null|class-string|object
         */
        public function getEntity() {}

        /**
         * Configure the form specification from annotations
         *
         * @triggers discoverName
         * @triggers configureForm
         */
        protected function configureForm(\Laminas\Form\Annotation\AnnotationCollection $annotations, \ReflectionClass $reflection, \ArrayObject $formSpec, \ArrayObject $filterSpec): void {}

        /**
         * Configure an element from annotations
         *
         * @triggers checkForExclude
         * @triggers discoverName
         * @triggers configureElement
         */
        protected function configureElement(\Laminas\Form\Annotation\AnnotationCollection $annotations, \ReflectionProperty $reflection, \ArrayObject $formSpec, \ArrayObject $filterSpec): void {}

        /**
         * @return $this
         */
        public function setPreserveDefinedOrder(bool $preserveDefinedOrder) {}

        public function preserveDefinedOrder(): bool {}

        /**
         * Discover the name of the given form or element
         */
        protected function discoverName(\Laminas\Form\Annotation\AnnotationCollection $annotations, \Reflector $reflection): string {}

        /**
         * Determine if an element is marked to exclude from the definitions
         *
         * @return true|false
         */
        protected function checkForExclude(\Laminas\Form\Annotation\AnnotationCollection $annotations): bool {}
    }

    /**
     * Parses the properties of a class for annotations in order to create a form
     * and input filter definition.
     */
    final class AnnotationBuilder extends \Laminas\Form\Annotation\AbstractBuilder
    {
        /**
         * Derive a form specification from doctrine annotations for a given entity
         *
         * @param object|class-string $entity
         *
         * @return array
         * @throws \ReflectionException
         */
        protected function getFormSpecificationInternal($entity): array {}
    }

    /**
     * Parses the properties of a class for PHP attributes in order to create a form
     * and input filter definition.
     */
    final class AttributeBuilder extends \Laminas\Form\Annotation\AbstractBuilder
    {
        /**
         * Initialize the attribute builder
         */
        public function __construct() {}

        /**
         * Derive a form specification from PHP attributes for a given entity
         *
         * @param object|class-string $entity
         *
         * @return array
         * @throws \ReflectionException
         */
        protected function getFormSpecificationInternal($entity): array {}
    }

    /**
     * Flags annotation
     *
     * Allows passing flags to the form factory. These flags are used to indicate
     * metadata, and typically the priority (order) in which an element will be
     * included.
     *
     * The value should be an associative array.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Flags
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private array $flags) {}

        /**
         * Retrieve the flags
         *
         * @return array
         */
        public function getFlags(): array {}
    }

    /**
     * Type annotation
     *
     * Use this annotation to specify the specific \Laminas\Form class to use when
     * building the form, fieldset, or element. The value should be a string
     * representing a fully qualified classname.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Type
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private string $type) {}

        /**
         * Retrieve the class type
         */
        public function getType(): string {}
    }

    /**
     * Input annotation
     *
     * Use this annotation to specify a specific input class to use with an element.
     * The value should be a string indicating the fully qualified class name of the
     * input to use.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Input
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private string $input) {}

        /**
         * Retrieve the input class
         */
        public function getInput(): string {}
    }

    final class BuilderAbstractFactory implements \Laminas\ServiceManager\Factory\AbstractFactoryInterface
    {
        /**
         * @param string     $requestedName
         * @param null|array $options
         *
         * @throws \Laminas\ServiceManager\Exception\ServiceNotCreatedException For invalid listener configuration.
         */
        public function __invoke(\Psr\Container\ContainerInterface $container, $requestedName, ?array $options = null): \Laminas\Form\Annotation\AbstractBuilder {}

        /**
         * @param string $requestedName
         */
        public function canCreate(\Psr\Container\ContainerInterface $container, $requestedName): bool {}
    }

    /**
     * Filter annotation
     *
     * Expects an associative array defining the filter.  Typically, this includes
     * the "name" with an associated string value indicating the filter name or
     * class, and optionally an "options" key with an object/associative array value
     * of options to pass to the filter constructor.
     *
     * This annotation may be specified multiple times; filters will be added
     * to the filter chain in the order specified.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute(\Attribute::IS_REPEATABLE | \Attribute::TARGET_ALL)]
    final class Filter
    {
        /**
         * Receive and process the contents of an annotation
         *
         * @param string|array $name
         */
        public function __construct($name, array $options = [], ?int $priority = null) {}

        /**
         * Retrieve the filter specification
         *
         * @return array
         */
        public function getFilterSpecification(): array {}
    }

    /**
     * Base annotations listener.
     *
     * Provides an implementation of detach() that should work with any listener.
     * Also provides listeners for the "Name" annotation -- handleNameAnnotation()
     * will listen for the "Name" annotation, while discoverFallbackName() listens
     * on the "discoverName" event and will use the class or property name, as
     * discovered via reflection, if no other annotation has provided the name
     * already.
     */
    abstract class AbstractAnnotationsListener extends \Laminas\EventManager\AbstractListenerAggregate
    {
        /**
         * Attempt to discover a name set via annotation
         *
         * @return false|string
         */
        public function handleNameAnnotation(\Laminas\EventManager\EventInterface $e) {}

        /**
         * Discover the fallback name via reflection
         */
        public function discoverFallbackName(\Laminas\EventManager\EventInterface $e): string {}
    }

    /**
     * Default listeners for element annotations
     *
     * Defines and attaches a set of default listeners for element annotations
     * (which are defined on object properties). These include:
     *
     * - AllowEmpty
     * - Attributes
     * - ErrorMessage
     * - Filter
     * - Flags
     * - Input
     * - Hydrator
     * - Object and Instance (the latter is preferred starting in 2.4)
     * - Required
     * - Type
     * - Validator
     *
     * See the individual annotation classes for more details. The handlers registered
     * work with the annotation values, as well as the element and input specification
     * passed in the event object.
     */
    final class ElementAnnotationsListener extends \Laminas\Form\Annotation\AbstractAnnotationsListener
    {
        /**
         * @inheritDoc
         */
        public function attach(\Laminas\EventManager\EventManagerInterface $events, $priority = 1) {}

        /**
         * Handle the AllowEmpty annotation
         *
         * Sets the allow_empty flag on the input specification array.
         */
        public function handleAllowEmptyAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Attributes annotation
         *
         * Sets the attributes array of the element specification.
         */
        public function handleAttributesAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Allow creating fieldsets from composed entity properties
         */
        public function handleComposedObjectAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the ContinueIfEmpty annotation
         *
         * Sets the continue_if_empty flag on the input specification array.
         */
        public function handleContinueIfEmptyAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the ErrorMessage annotation
         *
         * Sets the error_message of the input specification.
         */
        public function handleErrorMessageAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Determine if the element has been marked to exclude from the definition
         */
        public function handleExcludeAnnotation(\Laminas\EventManager\EventInterface $e): bool {}

        /**
         * Handle the Filter annotation
         *
         * Adds a filter to the filter chain specification for the input.
         */
        public function handleFilterAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Flags annotation
         *
         * Sets the element flags in the specification (used typically for setting
         * priority).
         */
        public function handleFlagsAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Hydrator annotation
         *
         * Sets the hydrator class to use in the fieldset specification.
         */
        public function handleHydratorAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Input annotation
         *
         * Sets the filter specification for the current element to the specified
         * input class name.
         */
        public function handleInputAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Instance annotations
         *
         * Sets the object to bind to the form or fieldset
         */
        public function handleInstanceAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Options annotation
         *
         * Sets the element options in the specification.
         */
        public function handleOptionsAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Required annotation
         *
         * Sets the required flag on the input based on the annotation value.
         */
        public function handleRequiredAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Type annotation
         *
         * Sets the element class type to use in the element specification.
         */
        public function handleTypeAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Validator annotation
         *
         * Adds a validator to the validator chain of the input specification.
         */
        public function handleValidatorAnnotation(\Laminas\EventManager\EventInterface $e): void {}
    }

    /**
     * ValidationGroup annotation
     *
     * Allows passing validation group to the form
     *
     * The value should be an associative array.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class ValidationGroup
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private array $validationGroup) {}

        /**
         * Retrieve the options
         *
         * @return array
         */
        public function getValidationGroup(): array {}
    }

    /**
     * ErrorMessage annotation
     *
     * Allows providing an error message to seed the Input specification for a
     * given element. The content should be a string.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class ErrorMessage
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private string $message) {}

        /**
         * Retrieve the message
         */
        public function getMessage(): string {}
    }

    /**
     * ComposedObject annotation
     *
     * Use this annotation to specify another object with annotations to parse
     * which you can then add to the form as a fieldset. The value should be a
     * string indicating the fully qualified class name of the composed object
     * to use.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class ComposedObject
    {
        /**
         * Receive and process the contents of an annotation
         *
         * @param array|string $targetObject
         */
        public function __construct($targetObject, bool $isCollection = false, array $options = []) {}

        /**
         * Retrieve the composed object classname
         */
        public function getComposedObject(): ?string {}

        /**
         * Is this composed object a collection or not
         */
        public function isCollection(): bool {}

        /**
         * Retrieve the options for the composed object
         *
         * @return array
         */
        public function getOptions(): array {}
    }

    /**
     * Exclude annotation
     *
     * Presence of this annotation hints to the AnnotationBuilder to skip the
     * element when creating the form specification.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Exclude
    {
    }

    /**
     * Attributes annotation
     *
     * Expects an array of attributes. The value is used to set any attributes on
     * the related form object (element, fieldset, or form).
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Attributes
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private array $attributes) {}

        /**
         * Retrieve the attributes
         *
         * @return array
         */
        public function getAttributes(): array {}
    }

    /**
     * AllowEmpty annotation
     *
     * Presence of this annotation is a hint that the associated
     * \Laminas\InputFilter\Input should enable the allowEmpty flag.
     *
     * @deprecated 2.4.8 Use `@Validator({"name":"NotEmpty"})` instead.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class AllowEmpty
    {
        /**
         * Receive and process the contents of an annotation
         *
         * @param bool|string $allowEmpty
         */
        public function __construct($allowEmpty = true) {}

        /**
         * Get value of required flag
         */
        public function getAllowEmpty(): bool {}
    }

    /**
     * Hydrator annotation
     *
     * Use this annotation to specify a specific hydrator class to use with the form.
     * The value should be a string indicating the fully qualified class name of the
     * hydrator to use.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Hydrator
    {
        /**
         * Receive and process the contents of an annotation
         *
         * @param string|array $type
         */
        public function __construct($type, array $options = []) {}

        /**
         * Retrieve the hydrator specification
         *
         * @return array
         */
        public function getHydratorSpecification(): array {}
    }

    /**
     * Instance (formerly "object") annotation
     *
     * Use this annotation to specify an object instance to use as the bound object
     * of a form or fieldset
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Instance
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private string $instance) {}

        /**
         * Retrieve the instance
         */
        public function getInstance(): string {}
    }

    /**
     * Default listeners for form annotations
     *
     * Defines and attaches a set of default listeners for form annotations
     * (which are defined on object properties). These include:
     *
     * - Attributes
     * - Flags
     * - Hydrator
     * - Object and Instance (the latter is preferred starting in 2.4)
     * - InputFilter
     * - Type
     * - ValidationGroup
     *
     * See the individual annotation classes for more details. The handlers
     * registered work with the annotation values, as well as the form
     * specification passed in the event object.
     */
    final class FormAnnotationsListener extends \Laminas\Form\Annotation\AbstractAnnotationsListener
    {
        /**
         * Attach listeners
         *
         * @inheritDoc
         */
        public function attach(\Laminas\EventManager\EventManagerInterface $events, $priority = 1) {}

        /**
         * Handle the Attributes annotation
         *
         * Sets the attributes key of the form specification.
         */
        public function handleAttributesAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Flags annotation
         *
         * Sets the flags key of the form specification.
         */
        public function handleFlagsAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Hydrator annotation
         *
         * Sets the hydrator class to use in the form specification.
         */
        public function handleHydratorAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the InputFilter annotation
         *
         * Sets the input filter class to use in the form specification.
         */
        public function handleInputFilterAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Instance annotations
         *
         * Sets the object to bind to the form or fieldset
         */
        public function handleInstanceAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Options annotation
         *
         * Sets the options key of the form specification.
         */
        public function handleOptionsAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the Type annotation
         *
         * Sets the form class to use in the form specification.
         */
        public function handleTypeAnnotation(\Laminas\EventManager\EventInterface $e): void {}

        /**
         * Handle the ValidationGroup annotation
         *
         * Sets the validation group to use in the form specification.
         */
        public function handleValidationGroupAnnotation(\Laminas\EventManager\EventInterface $e): void {}
    }

    /**
     * Required annotation
     *
     * Use this annotation to specify the value of the "required" flag for a given
     * input. Since the flag defaults to "true", this will typically be used to
     * "unset" the flag (e.g., "@Annotation\Required(false)"). Any boolean value
     * understood by \Laminas\Filter\Boolean is allowed as the content.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Required
    {
        /**
         * Receive and process the contents of an annotation
         *
         * @param bool|string $required
         */
        public function __construct($required = true) {}

        /**
         * Get value of required flag
         */
        public function getRequired(): bool {}
    }

    /**
     * Name annotation
     *
     * Use this annotation to specify a name other than the property or class name
     * when building the form, element, or input. The value should be a string.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Name
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private string $name) {}

        /**
         * Retrieve the name
         */
        public function getName(): string {}
    }

    /**
     * Validator annotation
     *
     * Expects an associative array defining the validator.
     *
     * Typically, this includes the "name" with an associated string value
     * indicating the validator name or class, and optionally an "options" key
     * with an object/associative array value of options to pass to the
     *
     *
     * This annotation may be specified multiple times; validators will be added
     * to the validator chain in the order specified.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute(\Attribute::IS_REPEATABLE | \Attribute::TARGET_ALL)]
    final class Validator
    {
        /**
         * Receive and process the contents of an annotation
         *
         * @param string|array $name
         */
        public function __construct($name, array $options = [], ?bool $breakChainOnFailure = null, ?int $priority = null) {}

        /**
         * Retrieve the validator specification
         *
         * @return array
         */
        public function getValidatorSpecification(): array {}
    }

    /**
     * @extends \ArrayObject<array-key, object>
     */
    final class AnnotationCollection extends \ArrayObject
    {
        /**
         * Checks if the collection has annotations for a class
         */
        public function hasAnnotation(string $class): bool {}
    }

    /**
     * Options annotation
     *
     * Allows passing element, fieldset, or form options to the form factory.
     * Options are used to alter the behavior of the object they address.
     *
     * The value should be an associative array.
     *
     * @Annotation
     * @NamedArgumentConstructor
     */
    #[\Attribute]
    final class Options
    {
        /**
         * Receive and process the contents of an annotation
         */
        public function __construct(private array $options) {}

        /**
         * Retrieve the options
         *
         * @return array
         */
        public function getOptions(): array {}
    }
}

namespace Laminas\Form\Exception {
    interface ExceptionInterface
    {
    }

    class BadMethodCallException extends \BadMethodCallException implements \Laminas\Form\Exception\ExceptionInterface
    {
    }

    class DomainException extends \DomainException implements \Laminas\Form\Exception\ExceptionInterface
    {
    }

    class ExtensionNotLoadedException extends \Laminas\Form\Exception\DomainException
    {
    }

    class InvalidArgumentException extends \InvalidArgumentException implements \Laminas\Form\Exception\ExceptionInterface
    {
    }

    class InvalidElementException extends \Laminas\Form\Exception\InvalidArgumentException
    {
    }

    class UnexpectedValueException extends \UnexpectedValueException implements \Laminas\Form\Exception\ExceptionInterface
    {
    }

    class IncompatiblePhpVersionException extends \RuntimeException implements \Laminas\Form\Exception\ExceptionInterface
    {
    }
}

namespace Laminas\Form\View\Helper {
    /**
     * Base functionality for all form view helpers
     */
    abstract class AbstractHelper extends \Laminas\I18n\View\Helper\AbstractTranslatorHelper
    {
        /**
         * The default translatable HTML attributes
         *
         * @var array
         */
        protected static $defaultTranslatableHtmlAttributes = ['title' => true];
        /**
         * The default translatable HTML attribute prefixes
         *
         * @var array
         */
        protected static $defaultTranslatableHtmlAttributePrefixes = [];
        /**
         * Standard boolean attributes, with expected values for enabling/disabling
         *
         * @var array
         */
        protected $booleanAttributes = [
            'autofocus' => ['on' => 'autofocus', 'off' => ''],
            // https://html.spec.whatwg.org/#attr-fe-autofocus
            'checked'   => ['on' => 'checked', 'off' => ''],
            // https://html.spec.whatwg.org/#attr-input-checked
            'disabled'  => ['on' => 'disabled', 'off' => ''],
            // https://html.spec.whatwg.org/#attr-fe-disabled
            'itemscope' => ['on' => 'itemscope', 'off' => ''],
            // https://html.spec.whatwg.org/#attr-itemscope
            'multiple'  => ['on' => 'multiple', 'off' => ''],
            // https://html.spec.whatwg.org/#attr-input-multiple
            'readonly'  => ['on' => 'readonly', 'off' => ''],
            // https://html.spec.whatwg.org/#attr-input-readonly
            'required'  => ['on' => 'required', 'off' => ''],
            // https://html.spec.whatwg.org/#attr-input-required
            'selected'  => ['on' => 'selected', 'off' => ''],
        ];
        /**
         * Translatable attributes
         *
         * @var array<string, bool>
         */
        protected $translatableAttributes = ['placeholder' => true];
        /**
         * Prefixes of translatable HTML attributes
         *
         * @var array
         */
        protected $translatableAttributePrefixes = [];
        /** @var null|\Laminas\View\Helper\Doctype */
        protected $doctypeHelper;
        /** @var null|\Laminas\View\Helper\EscapeHtml */
        protected $escapeHtmlHelper;
        /** @var null|\Laminas\View\Helper\EscapeHtmlAttr */
        protected $escapeHtmlAttrHelper;
        /**
         * Attributes globally valid for all tags
         *
         * @var array
         */
        protected $validGlobalAttributes = [
            'accesskey'          => true,
            // https://html.spec.whatwg.org/#the-accesskey-attribute
            'autocapitalize'     => true,
            // https://html.spec.whatwg.org/#attr-autocapitalize
            'class'              => true,
            // https://html.spec.whatwg.org/#classes
            'contenteditable'    => true,
            // https://html.spec.whatwg.org/#contenteditable
            'contextmenu'        => true,
            // Obsolete: https://html.spec.whatwg.org/#attr-contextmenu
            'dir'                => true,
            // https://html.spec.whatwg.org/#the-dir-attribute
            'draggable'          => true,
            // https://html.spec.whatwg.org/#the-draggable-attribute
            'dropzone'           => true,
            // Obsolete: https://html.spec.whatwg.org/#attr-dropzone
            'enterkeyhint'       => true,
            // https://html.spec.whatwg.org/#input-modalities:-the-enterkeyhint-attribute
            'hidden'             => true,
            // https://html.spec.whatwg.org/#the-hidden-attribute
            'id'                 => true,
            // https://html.spec.whatwg.org/#the-id-attribute
            'inputmode'          => true,
            // https://html.spec.whatwg.org/#attr-inputmode
            'is'                 => true,
            // https://html.spec.whatwg.org/#attr-is
            //'itemid'             => true, // https://html.spec.whatwg.org/#attr-itemid
            'itemprop'           => true,
            // https://html.spec.whatwg.org/#names:-the-itemprop-attribute
            'itemref'            => true,
            // https://html.spec.whatwg.org/#attr-itemref
            'itemscope'          => true,
            // https://html.spec.whatwg.org/#attr-itemscope
            'itemtype'           => true,
            // https://html.spec.whatwg.org/#attr-itemtype
            'lang'               => true,
            // https://html.spec.whatwg.org/#the-lang-and-xml:lang-attributes
            //'nonce'              => true, // https://html.spec.whatwg.org/#attr-nonce
            'onabort'            => true,
            // https://html.spec.whatwg.org/#handler-onabort
            'onblur'             => true,
            // https://html.spec.whatwg.org/#handler-onblur
            'oncanplay'          => true,
            // https://html.spec.whatwg.org/#handler-oncanplay
            'oncanplaythrough'   => true,
            // https://html.spec.whatwg.org/#handler-oncanplaythrough
            'onchange'           => true,
            // https://html.spec.whatwg.org/#handler-onchange
            'onclick'            => true,
            // https://html.spec.whatwg.org/#handler-onclick
            'oncontextmenu'      => true,
            // https://html.spec.whatwg.org/#handler-oncontextmenu
            'ondblclick'         => true,
            // https://html.spec.whatwg.org/#handler-ondblclick
            'ondrag'             => true,
            // https://html.spec.whatwg.org/#handler-ondrag
            'ondragend'          => true,
            // https://html.spec.whatwg.org/#handler-ondragend
            'ondragenter'        => true,
            // https://html.spec.whatwg.org/#handler-ondragenter
            'ondragleave'        => true,
            // https://html.spec.whatwg.org/#handler-ondragleave
            'ondragover'         => true,
            // https://html.spec.whatwg.org/#handler-ondragover
            'ondragstart'        => true,
            // https://html.spec.whatwg.org/#handler-ondragstart
            'ondrop'             => true,
            // https://html.spec.whatwg.org/#handler-ondrop
            'ondurationchange'   => true,
            // https://html.spec.whatwg.org/#handler-ondurationchange
            'onemptied'          => true,
            // https://html.spec.whatwg.org/#handler-onemptied
            'onended'            => true,
            // https://html.spec.whatwg.org/#handler-onended
            'onerror'            => true,
            // https://html.spec.whatwg.org/#handler-onerror
            'onfocus'            => true,
            // https://html.spec.whatwg.org/#handler-onfocus
            'onfocusin'          => true,
            // https://developer.mozilla.org/fr/docs/Web/API/Element/focusin_event
            'onfocusout'         => true,
            // https://developer.mozilla.org/fr/docs/Web/API/Element/focusout_event
            'oninput'            => true,
            // https://html.spec.whatwg.org/#handler-oninput
            'oninvalid'          => true,
            // https://html.spec.whatwg.org/#handler-oninvalid
            'onkeydown'          => true,
            // https://html.spec.whatwg.org/#handler-onkeydown
            'onkeypress'         => true,
            // https://html.spec.whatwg.org/#handler-onkeypress
            'onkeyup'            => true,
            // https://html.spec.whatwg.org/#handler-onkeyup
            'onload'             => true,
            // https://html.spec.whatwg.org/#handler-onload
            'onloadeddata'       => true,
            // https://html.spec.whatwg.org/#handler-onloadeddata
            'onloadedmetadata'   => true,
            // https://html.spec.whatwg.org/#handler-onloadedmetadata
            'onloadstart'        => true,
            // https://html.spec.whatwg.org/#handler-onloadstart
            'onmousedown'        => true,
            // https://html.spec.whatwg.org/#handler-onmousedown
            'onmousemove'        => true,
            // https://html.spec.whatwg.org/#handler-onmousemove
            'onmouseout'         => true,
            // https://html.spec.whatwg.org/#handler-onmouseout
            'onmouseover'        => true,
            // https://html.spec.whatwg.org/#handler-onmouseover
            'onmouseup'          => true,
            // https://html.spec.whatwg.org/#handler-onmouseup
            'onmousewheel'       => true,
            // https://html.spec.whatwg.org/#handler-onmousewheel
            'onpause'            => true,
            // https://html.spec.whatwg.org/#handler-onpause
            'onplay'             => true,
            // https://html.spec.whatwg.org/#handler-onplay
            'onplaying'          => true,
            // https://html.spec.whatwg.org/#handler-onplaying
            'onprogress'         => true,
            // https://html.spec.whatwg.org/#handler-onprogress
            'onratechange'       => true,
            // https://html.spec.whatwg.org/#handler-onratechange
            'onreadystatechange' => true,
            // https://html.spec.whatwg.org/#handler-onreadystatechange
            'onreset'            => true,
            // https://html.spec.whatwg.org/#handler-onreset
            'onscroll'           => true,
            // https://html.spec.whatwg.org/#handler-onscroll
            'onseeked'           => true,
            // https://html.spec.whatwg.org/#handler-onseeked
            'onseeking'          => true,
            // https://html.spec.whatwg.org/#handler-onseeking
            'onselect'           => true,
            // https://html.spec.whatwg.org/#handler-onselect
            'onshow'             => true,
            // https://html.spec.whatwg.org/#handler-onshow
            'onstalled'          => true,
            // https://html.spec.whatwg.org/#handler-onstalled
            'onsubmit'           => true,
            // https://html.spec.whatwg.org/#handler-onsubmit
            'onsuspend'          => true,
            // https://html.spec.whatwg.org/#handler-onsuspend
            'ontimeupdate'       => true,
            // https://html.spec.whatwg.org/#handler-ontimeupdate
            'onvolumechange'     => true,
            // https://html.spec.whatwg.org/#handler-onvolumechange
            'onwaiting'          => true,
            // https://html.spec.whatwg.org/#handler-onwaiting
            'role'               => true,
            // https://html.spec.whatwg.org/#attr-aria-role
            'slot'               => true,
            // https://html.spec.whatwg.org/#attr-slot
            'spellcheck'         => true,
            // https://html.spec.whatwg.org/#attr-spellcheck
            'style'              => true,
            // https://html.spec.whatwg.org/#attr-style
            'tabindex'           => true,
            // https://html.spec.whatwg.org/#attr-tabindex
            'title'              => true,
            // https://html.spec.whatwg.org/#attr-title
            //'translate'          => true, // https://html.spec.whatwg.org/#attr-translate
            'xml:base'           => true,
            // https://www.w3.org/TR/xmlbase/#syntax
            'xml:lang'           => true,
            // https://html.spec.whatwg.org/#the-lang-and-xml:lang-attributes
            'xml:space'          => true,
        ];
        /**
         * Attribute prefixes valid for all tags
         *
         * @var array
         */
        protected $validTagAttributePrefixes = [
            'data-',
            // https://html.spec.whatwg.org/#attr-data-*
            'aria-',
            // https://html.spec.whatwg.org/#attr-aria-*
            'x-',
        ];
        /**
         * Attributes valid for the tag represented by this helper
         *
         * This should be overridden in extending classes
         *
         * @var array
         */
        protected $validTagAttributes = [];

        /**
         * Set value for doctype
         *
         * @return $this
         */
        public function setDoctype(string $doctype) {}

        /**
         * Get value for doctype
         */
        public function getDoctype(): string {}

        /**
         * Set value for character encoding
         *
         * @return $this
         */
        public function setEncoding(string $encoding) {}

        /**
         * Get character encoding
         */
        public function getEncoding(): string {}

        /**
         * Create a string of all attribute/value pairs
         *
         * Escapes all attribute values
         *
         * @param array $attributes
         */
        public function createAttributesString(array $attributes): string {}

        /**
         * Get the ID of an element
         *
         * If no ID attribute present, attempts to use the name attribute.
         * If no name attribute is present, either, returns null.
         */
        public function getId(\Laminas\Form\ElementInterface $element): ?string {}

        /**
         * Get the closing bracket for an inline tag
         *
         * Closes as either "/>" for XHTML doctypes or ">" otherwise.
         */
        public function getInlineClosingBracket(): string {}

        /**
         * Retrieve the doctype helper
         */
        protected function getDoctypeHelper(): \Laminas\View\Helper\Doctype {}

        /**
         * Retrieve the escapeHtml helper
         */
        protected function getEscapeHtmlHelper(): \Laminas\View\Helper\EscapeHtml {}

        /**
         * Retrieve the escapeHtmlAttr helper
         */
        protected function getEscapeHtmlAttrHelper(): \Laminas\View\Helper\EscapeHtmlAttr {}

        /**
         * Prepare attributes for rendering
         *
         * Ensures appropriate attributes are present (e.g., if "name" is present,
         * but no "id", sets the latter to the former).
         *
         * Removes any invalid attributes
         *
         * @param array $attributes
         *
         * @return array
         */
        protected function prepareAttributes(array $attributes): array {}

        /**
         * Prepare a boolean attribute value
         *
         * Prepares the expected representation for the boolean attribute specified.
         */
        protected function prepareBooleanAttributeValue(string $attribute, mixed $value): string {}

        /**
         * Translates the value of the HTML attribute if it should be translated and this view helper has a translator
         */
        protected function translateHtmlAttributeValue(string $key, ?string $value): ?string {}

        /**
         * Adds an HTML attribute to the list of valid attributes
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException For attribute names that are invalid per the HTML specifications.
         */
        public function addValidAttribute(string $attribute) {}

        /**
         * Adds a prefix to the list of valid attribute prefixes
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException For attribute prefixes that are invalid
         *                                  per the HTML specifications for attribute names.
         */
        public function addValidAttributePrefix(string $prefix) {}

        /**
         * Adds an HTML attribute to the list of translatable attributes
         *
         * @return $this
         */
        public function addTranslatableAttribute(string $attribute) {}

        /**
         * Adds an HTML attribute to the list of the default translatable attributes
         */
        public static function addDefaultTranslatableAttribute(string $attribute): void {}

        /**
         * Adds an HTML attribute to the list of translatable attributes
         *
         * @return $this
         */
        public function addTranslatableAttributePrefix(string $prefix) {}

        /**
         * Adds an HTML attribute to the list of translatable attributes
         */
        public static function addDefaultTranslatableAttributePrefix(string $prefix): void {}

        /**
         * Whether the passed attribute is valid or not
         *
         * @see https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
         *     Description of valid attributes
         */
        protected function isValidAttributeName(string $attribute): bool {}

        /**
         * Whether the passed attribute has a valid prefix or not
         */
        protected function hasAllowedPrefix(string $attribute): bool {}
    }

    class FormInput extends \Laminas\Form\View\Helper\AbstractHelper
    {
        /**
         * Attributes valid for the input tag
         *
         * @var array
         */
        protected $validTagAttributes = ['name'       => true, 'accept' => true, 'alt' => true, 'autocomplete' => true, 'autofocus' => true, 'checked' => true, 'dirname' => true,
                                         'disabled'   => true, 'form' => true, 'formaction' => true, 'formenctype' => true, 'formmethod' => true, 'formnovalidate' => true,
                                         'formtarget' => true, 'height' => true, 'list' => true, 'max' => true, 'maxlength' => true, 'min' => true, 'multiple' => true,
                                         'pattern'    => true, 'placeholder' => true, 'readonly' => true, 'required' => true, 'size' => true, 'src' => true, 'step' => true,
                                         'type'       => true, 'value' => true, 'width' => true];
        /**
         * Valid values for the input type
         *
         * @var array
         */
        protected $validTypes = ['text'  => true, 'button' => true, 'checkbox' => true, 'file' => true, 'hidden' => true, 'image' => true, 'password' => true, 'radio' => true,
                                 'reset' => true, 'select' => true, 'submit' => true, 'color' => true, 'date' => true, 'datetime' => true, 'datetime-local' => true,
                                 'email' => true, 'month' => true, 'number' => true, 'range' => true, 'search' => true, 'tel' => true, 'time' => true, 'url' => true,
                                 'week'  => true];

        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormInput
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null) {}

        /**
         * Render a form <input> element from the provided $element
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    abstract class AbstractFormDateTime extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="datetime"
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'list' => true, 'max' => true,
                                         'min'  => true, 'readonly' => true, 'required' => true, 'step' => true, 'type' => true, 'value' => true];
    }

    class FormMonth extends \Laminas\Form\View\Helper\AbstractFormDateTime
    {
        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormSubmit extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="submit"
         *
         * @var array
         */
        protected $validTagAttributes = ['name'       => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'formaction' => true, 'formenctype' => true,
                                         'formmethod' => true, 'formnovalidate' => true, 'formtarget' => true, 'type' => true, 'value' => true];
        /**
         * Translatable attributes
         *
         * @var array<string, bool>
         */
        protected $translatableAttributes = ['value' => true];

        /**
         * Determine input type to use
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormText extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="text"
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true, 'autocomplete' => true, 'autofocus' => true, 'dirname' => true, 'disabled' => true, 'form' => true, 'inputmode' => true,
                                         'list' => true, 'maxlength' => true, 'minlength' => true, 'pattern' => true, 'placeholder' => true, 'readonly' => true, 'required' => true,
                                         'size' => true, 'type' => true, 'value' => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    /**
     * FormSearch view helper
     *
     * The difference between the Text state and the Search state is primarily stylistic:
     * on platforms where search fields are distinguished from regular text fields,
     * the Search state might result in an appearance consistent with the platform's
     * search fields rather than appearing like a regular text field.
     */
    class FormSearch extends \Laminas\Form\View\Helper\FormText
    {
        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormColor extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="color"
         *
         * @var array
         */
        protected $validTagAttributes = ['name'  => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'list' => true, 'type' => true,
                                         'value' => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormCollection extends \Laminas\Form\View\Helper\AbstractHelper
    {
        /**
         * Attributes valid for this tag (form)
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true];
        /**
         * If set to true, collections are automatically wrapped around a fieldset
         *
         * @var bool
         */
        protected $shouldWrap = true;
        /**
         * This is the default wrapper that the collection is wrapped into
         *
         * @var string
         */
        protected $wrapper = '<fieldset%4$s>%2$s%1$s%3$s</fieldset>';
        /**
         * This is the default label-wrapper
         *
         * @var string
         */
        protected $labelWrapper = '<legend>%s</legend>';
        /**
         * Where shall the template-data be inserted into
         *
         * @var string
         */
        protected $templateWrapper = '<span data-template="%s"></span>';
        /**
         * The name of the default view helper that is used to render sub elements.
         *
         * @var string
         */
        protected $defaultElementHelper = 'formrow';
        /**
         * The view helper used to render sub elements.
         *
         * @var null|\Laminas\View\Helper\HelperInterface
         */
        protected $elementHelper;
        /**
         * The view helper used to render sub fieldsets.
         *
         * @var null|\Laminas\View\Helper\HelperInterface
         */
        protected $fieldsetHelper;

        /**
         * Invoke helper as function
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormCollection
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, bool $wrap = true) {}

        /**
         * Render a collection by iterating through all fieldsets and elements
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Only render a template
         */
        public function renderTemplate(\Laminas\Form\Element\Collection $collection): string {}

        /**
         * If set to true, collections are automatically wrapped around a fieldset
         *
         * @return $this
         */
        public function setShouldWrap(bool $wrap) {}

        /**
         * Get wrapped
         */
        public function shouldWrap(): bool {}

        /**
         * Sets the name of the view helper that should be used to render sub elements.
         *
         * @param string $defaultSubHelper The name of the view helper to set.
         *
         * @return $this
         */
        public function setDefaultElementHelper(string $defaultSubHelper) {}

        /**
         * Gets the name of the view helper that should be used to render sub elements.
         */
        public function getDefaultElementHelper(): string {}

        /**
         * Sets the element helper that should be used by this collection.
         *
         * @param \Laminas\View\Helper\HelperInterface $elementHelper The element helper to use.
         *
         * @return $this
         */
        public function setElementHelper(\Laminas\View\Helper\HelperInterface $elementHelper) {}

        /**
         * Retrieve the element helper.
         *
         * @throws \RuntimeException
         */
        protected function getElementHelper(): \Laminas\View\Helper\HelperInterface {}

        /**
         * Sets the fieldset helper that should be used by this collection.
         *
         * @param \Laminas\View\Helper\HelperInterface $fieldsetHelper The fieldset helper to use.
         *
         * @return $this
         */
        public function setFieldsetHelper(\Laminas\View\Helper\HelperInterface $fieldsetHelper) {}

        /**
         * Retrieve the fieldset helper.
         */
        protected function getFieldsetHelper(): \Laminas\View\Helper\HelperInterface {}

        /**
         * Get the wrapper for the collection
         */
        public function getWrapper(): string {}

        /**
         * Set the wrapper for this collection
         *
         * The string given will be passed through sprintf with the following three
         * replacements:
         *
         * 1. The content of the collection
         * 2. The label of the collection. If no label is given this will be an empty
         *   string
         * 3. The template span-tag. This might also be an empty string
         *
         * The preset default is <pre><fieldset>%2$s%1$s%3$s</fieldset></pre>
         *
         * @return $this
         */
        public function setWrapper(string $wrapper) {}

        /**
         * Set the label-wrapper
         * The string will be passed through sprintf with the label as single
         * parameter
         * This defaults to '<legend>%s</legend>'
         *
         * @return $this
         */
        public function setLabelWrapper(string $labelWrapper) {}

        /**
         * Get the wrapper for the label
         */
        public function getLabelWrapper(): string {}

        /**
         * Ge the wrapper for the template
         */
        public function getTemplateWrapper(): string {}

        /**
         * Set the string where the template will be inserted into
         *
         * This string will be passed through sprintf and has the template as single
         * parameter
         *
         * THis defaults to '<span data-template="%s"></span>'
         *
         * @return $this
         */
        public function setTemplateWrapper(string $templateWrapper) {}
    }

    /**
     * View helper for rendering Form objects
     */
    class Form extends \Laminas\Form\View\Helper\AbstractHelper
    {
        /**
         * Attributes valid for this tag (form)
         *
         * @var array
         */
        protected $validTagAttributes = ['accept-charset' => true, 'action' => true, 'autocomplete' => true, 'enctype' => true, 'method' => true, 'name' => true,
                                         'novalidate'     => true, 'target' => true];

        /**
         * Invoke as function
         *
         * @template T as null|\Laminas\Form\FormInterface
         * @psalm-param T $form
         * @psalm-return (T is null ? self : string)
         * @return Form|string
         */
        public function __invoke(?\Laminas\Form\FormInterface $form = null) {}

        /**
         * Render a form from the provided $form,
         */
        public function render(\Laminas\Form\FormInterface $form): string {}

        /**
         * Generate an opening form tag
         */
        public function openTag(?\Laminas\Form\FormInterface $form = null): string {}

        /**
         * Generate a closing form tag
         */
        public function closeTag(): string {}
    }

    class FormCheckbox extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Render a form <input> element from the provided $element
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Return input type
         */
        protected function getInputType(): string {}
    }

    /**
     * @deprecated 3.0.0 This element is deprecated starting with 3.0.0 as it has been removed from WHATWG HTML
     *
     * @see        https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/datetime
     */
    class FormDateTime extends \Laminas\Form\View\Helper\AbstractFormDateTime
    {
        /**
         * Attributes valid for the input tag type="datetime"
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'list' => true, 'max' => true,
                                         'min'  => true, 'readonly' => true, 'required' => true, 'step' => true, 'type' => true, 'value' => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormHidden extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="hidden"
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true, 'disabled' => true, 'form' => true, 'type' => true, 'value' => true, 'autocomplete' => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormEmail extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="email"
         *
         * @var array
         */
        protected $validTagAttributes = ['name'      => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'list' => true, 'maxlength' => true,
                                         'minlength' => true, 'multiple' => true, 'pattern' => true, 'placeholder' => true, 'readonly' => true, 'required' => true, 'size' => true,
                                         'type'      => true, 'value' => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormElementErrors extends \Laminas\Form\View\Helper\AbstractHelper
    {
        /** @var string Templates for the open/close/separators for message tags */
        protected $messageOpenFormat = '<ul%s><li>';
        /** @var string Templates for the open/close/separators for message tags */
        protected $messageCloseString = '</li></ul>';
        /** @var string Templates for the open/close/separators for message tags */
        protected $messageSeparatorString = '</li><li>';
        /** @var array Default attributes for the open format tag */
        protected $attributes = [];
        /** @var bool Whether or not to translate error messages during render. */
        protected $translateErrorMessages = true;

        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()} if an element is passed.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         *
         *
         * @param array   $attributes
         *
         * @return string|FormElementErrors
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, array $attributes = []) {}

        /**
         * Render validation errors for the provided $element
         *
         * If {@link $translateErrorMessages} is true, and a translator is
         * composed, messages retrieved from the element will be translated; if
         * either is not the case, they will not.
         *
         * @param array $attributes
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element, array $attributes = []): string {}

        /**
         * Set the attributes that will go on the message open format
         *
         * @param array $attributes key value pairs of attributes
         *
         * @return $this
         */
        public function setAttributes(array $attributes) {}

        /**
         * Get the attributes that will go on the message open format
         *
         * @return array
         */
        public function getAttributes(): array {}

        /**
         * Set the string used to close message representation
         *
         * @return $this
         */
        public function setMessageCloseString(string $messageCloseString) {}

        /**
         * Get the string used to close message representation
         */
        public function getMessageCloseString(): string {}

        /**
         * Set the formatted string used to open message representation
         *
         * @return $this
         */
        public function setMessageOpenFormat(string $messageOpenFormat) {}

        /**
         * Get the formatted string used to open message representation
         */
        public function getMessageOpenFormat(): string {}

        /**
         * Set the string used to separate messages
         *
         * @return $this
         */
        public function setMessageSeparatorString(string $messageSeparatorString) {}

        /**
         * Get the string used to separate messages
         */
        public function getMessageSeparatorString(): string {}

        /**
         * Set the flag detailing whether or not to translate error messages.
         *
         * @return $this
         */
        public function setTranslateMessages(bool $flag) {}
    }

    class FormImage extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="image"
         *
         * @var array
         */
        protected $validTagAttributes = ['name'       => true, 'alt' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'formaction' => true, 'formenctype' => true,
                                         'formmethod' => true, 'formnovalidate' => true, 'formtarget' => true, 'height' => true, 'src' => true, 'type' => true, 'width' => true];

        /**
         * Render a form <input> element from the provided $element
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormReset extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="reset"
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'type' => true, 'value' => true];
        /**
         * Translatable attributes
         *
         * @var array<string, bool>
         */
        protected $translatableAttributes = ['value' => true];

        /**
         * Determine input type to use
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormFile extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="file"
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true, 'accept' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'multiple' => true, 'required' => true,
                                         'type' => true];

        /**
         * Render a form <input> element from the provided $element
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormTextarea extends \Laminas\Form\View\Helper\AbstractHelper
    {
        /**
         * Attributes valid for the input tag
         *
         * @var array
         */
        protected $validTagAttributes = ['autocomplete' => true, 'autofocus' => true, 'cols' => true, 'dirname' => true, 'disabled' => true, 'form' => true, 'inputmode' => true,
                                         'maxlength'    => true, 'minlength' => true, 'name' => true, 'placeholder' => true, 'readonly' => true, 'required' => true, 'rows' => true,
                                         'wrap'         => true];

        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormTextarea
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null) {}

        /**
         * Render a form <textarea> element from the provided $element
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormUrl extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="url"
         *
         * @var array
         */
        protected $validTagAttributes = ['name'      => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'list' => true, 'maxlength' => true,
                                         'minlength' => true, 'pattern' => true, 'placeholder' => true, 'readonly' => true, 'required' => true, 'size' => true, 'type' => true,
                                         'value'     => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormDateTimeLocal extends \Laminas\Form\View\Helper\AbstractFormDateTime
    {
        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormWeek extends \Laminas\Form\View\Helper\AbstractFormDateTime
    {
        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormMultiCheckbox extends \Laminas\Form\View\Helper\FormInput
    {
        public const LABEL_APPEND  = 'append';
        public const LABEL_PREPEND = 'prepend';
        /**
         * The attributes applied to option label
         *
         * @var null|array
         */
        protected $labelAttributes;
        /**
         * Where will be label rendered?
         *
         * @var string
         */
        protected $labelPosition = self::LABEL_APPEND;
        /**
         * Separator for checkbox elements
         *
         * @var string
         */
        protected $separator = '';
        /**
         * Prefixing the element with a hidden element for the unset value?
         *
         * @var bool
         */
        protected $useHiddenElement = false;
        /**
         * The unchecked value used when "UseHiddenElement" is turned on
         *
         * @var string
         */
        protected $uncheckedValue = '';
        /**
         * Form input helper instance
         *
         * @var null|FormInput
         */
        protected $inputHelper;
        /**
         * Form label helper instance
         *
         * @var null|FormLabel
         */
        protected $labelHelper;

        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormMultiCheckbox
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, ?string $labelPosition = null) {}

        /**
         * Render a form <input> element from the provided $element
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Render options
         */
        protected function renderOptions(\Laminas\Form\Element\MultiCheckbox $element, array $options, array $selectedOptions, array $attributes): string {}

        /**
         * Render a hidden element for empty/unchecked value
         */
        protected function renderHiddenElement(\Laminas\Form\Element\MultiCheckbox $element): string {}

        /**
         * Sets the attributes applied to option label.
         *
         * @return $this
         */
        public function setLabelAttributes(?array $attributes) {}

        /**
         * Returns the attributes applied to each option label.
         *
         * @return array|null
         */
        public function getLabelAttributes(): ?array {}

        /**
         * Set value for labelPosition
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setLabelPosition(string $labelPosition) {}

        /**
         * Get position of label
         */
        public function getLabelPosition(): string {}

        /**
         * Set separator string for checkbox elements
         *
         * @return $this
         */
        public function setSeparator(string $separator) {}

        /**
         * Get separator for checkbox elements
         */
        public function getSeparator(): string {}

        /**
         * Sets the option for prefixing the element with a hidden element
         * for the unset value.
         *
         * @return $this
         */
        public function setUseHiddenElement(bool $useHiddenElement) {}

        /**
         * Returns the option for prefixing the element with a hidden element
         * for the unset value.
         */
        public function getUseHiddenElement(): bool {}

        /**
         * Sets the unchecked value used when "UseHiddenElement" is turned on.
         *
         * @return $this
         */
        public function setUncheckedValue(string $value) {}

        /**
         * Returns the unchecked value used when "UseHiddenElement" is turned on.
         */
        public function getUncheckedValue(): string {}

        /**
         * Return input type
         */
        protected function getInputType(): string {}

        /**
         * Get element name
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        protected static function getName(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Retrieve the FormInput helper
         */
        protected function getInputHelper(): \Laminas\Form\View\Helper\FormInput {}

        /**
         * Retrieve the FormLabel helper
         */
        protected function getLabelHelper(): \Laminas\Form\View\Helper\FormLabel {}
    }

    class FormRadio extends \Laminas\Form\View\Helper\FormMultiCheckbox
    {
        /**
         * Return input type
         */
        protected function getInputType(): string {}

        /**
         * Get element name
         */
        protected static function getName(\Laminas\Form\ElementInterface $element): string {}
    }

    abstract class AbstractFormDateSelect extends \Laminas\Form\View\Helper\AbstractHelper
    {
        /**
         * FormSelect helper
         *
         * @var null|FormSelect
         */
        protected $selectHelper;
        /**
         * Date formatter to use
         *
         * @var int
         */
        protected $dateType;
        /**
         * Pattern to use for Date rendering
         *
         * @var null|string
         */
        protected $pattern;
        /**
         * Locale to use
         *
         * @var null|string
         */
        protected $locale;

        /**
         * @throws \Laminas\Form\Exception\ExtensionNotLoadedException If ext/intl is not present.
         */
        public function __construct() {}

        /**
         * Parse the pattern
         *
         * @return array
         */
        protected function parsePattern(bool $renderDelimiters = true): array {}

        /**
         * Retrieve pattern to use for Date rendering
         */
        public function getPattern(): string {}

        /**
         * Set date formatter
         *
         * @return $this
         */
        public function setDateType(int $dateType) {}

        /**
         * Get date formatter
         */
        public function getDateType(): int {}

        /**
         * Set locale
         *
         * @return $this
         */
        public function setLocale(string $locale) {}

        /**
         * Get locale
         */
        public function getLocale(): string {}

        /**
         * Create a key => value options for months
         *
         * @param string $pattern Pattern to use for months
         *
         * @return array
         */
        protected function getMonthsOptions(string $pattern): array {}

        /**
         * Create a key => value options for years
         * NOTE: we don't use a pattern for years, as years written as two digits can lead to hard to
         * read date for users, so we only use four digits years
         *
         * @return array
         */
        protected function getYearsOptions(int $minYear, int $maxYear): array {}

        /**
         * Retrieve the FormSelect helper
         */
        protected function getSelectElementHelper(): \Laminas\Form\View\Helper\FormSelect {}
    }

    class FormDateTimeSelect extends \Laminas\Form\View\Helper\AbstractFormDateSelect
    {
        /**
         * Time formatter to use
         *
         * @var int
         */
        protected $timeType;

        /**
         * @throws \Laminas\Form\Exception\ExtensionNotLoadedException If ext/intl is not present.
         */
        public function __construct() {}

        /**
         * Invoke helper as function
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|self
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, int $dateType = \IntlDateFormatter::LONG, int $timeType = \IntlDateFormatter::LONG, ?string $locale = null) {}

        /**
         * Render a date element that is composed of six selects
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * @return $this
         */
        public function setTimeType(int $timeType) {}

        public function getTimeType(): int {}

        /**
         * Override to also get time part
         */
        public function getPattern(): string {}

        /**
         * Parse the pattern
         *
         * @return array
         */
        protected function parsePattern(bool $renderDelimiters = true): array {}

        /**
         * Create a key => value options for days
         *
         * @param string $pattern Pattern to use for days
         *
         * @return array
         */
        protected function getDaysOptions(string $pattern): array {}

        /**
         * Create a key => value options for hours
         *
         * @param string $pattern Pattern to use for hours
         *
         * @return array
         */
        protected function getHoursOptions(string $pattern): array {}

        /**
         * Create a key => value options for minutes
         *
         * @param string $pattern Pattern to use for minutes
         *
         * @return array
         */
        protected function getMinutesOptions(string $pattern): array {}

        /**
         * Create a key => value options for seconds
         *
         * @param string $pattern Pattern to use for seconds
         *
         * @return array
         */
        protected function getSecondsOptions(string $pattern): array {}
    }

    class FormElement extends \Laminas\View\Helper\AbstractHelper
    {
        public const DEFAULT_HELPER = 'forminput';
        /**
         * Instance map to view helper
         *
         * @var array
         */
        protected $classMap = [\Laminas\Form\Element\Button::class         => 'formbutton', \Laminas\Form\Element\Captcha::class => 'formcaptcha',
                               \Laminas\Form\Element\Csrf::class           => 'formhidden', \Laminas\Form\Element\Collection::class => 'formcollection',
                               \Laminas\Form\Element\DateTimeSelect::class => 'formdatetimeselect', \Laminas\Form\Element\DateSelect::class => 'formdateselect',
                               \Laminas\Form\Element\MonthSelect::class    => 'formmonthselect'];
        /**
         * Type map to view helper
         *
         * @var array
         */
        protected $typeMap = ['checkbox'       => 'formcheckbox', 'color' => 'formcolor', 'date' => 'formdate', 'datetime' => 'formdatetime',
                              'datetime-local' => 'formdatetimelocal', 'email' => 'formemail', 'file' => 'formfile', 'hidden' => 'formhidden', 'image' => 'formimage',
                              'month'          => 'formmonth', 'multi_checkbox' => 'formmulticheckbox', 'number' => 'formnumber', 'password' => 'formpassword',
                              'radio'          => 'formradio', 'range' => 'formrange', 'reset' => 'formreset', 'search' => 'formsearch', 'select' => 'formselect',
                              'submit'         => 'formsubmit', 'tel' => 'formtel', 'text' => 'formtext', 'textarea' => 'formtextarea', 'time' => 'formtime', 'url' => 'formurl',
                              'week'           => 'formweek'];
        /**
         * Default helper name
         *
         * @var string
         */
        protected $defaultHelper = self::DEFAULT_HELPER;

        /**
         * Invoke helper as function
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|self
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null) {}

        /**
         * Render an element
         *
         * Introspects the element type and attributes to determine which
         * helper to utilize when rendering.
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Set default helper name
         *
         * @return $this
         */
        public function setDefaultHelper(string $name) {}

        /**
         * Add form element type to plugin map
         *
         * @return $this
         */
        public function addType(string $type, string $plugin) {}

        /**
         * Add instance class to plugin map
         *
         * @return $this
         */
        public function addClass(string $class, string $plugin) {}

        /**
         * Render element by helper name
         */
        protected function renderHelper(string $name, \Laminas\Form\ElementInterface $element): string {}

        /**
         * Render element by instance map
         */
        protected function renderInstance(\Laminas\Form\ElementInterface $element): ?string {}

        /**
         * Render element by type map
         */
        protected function renderType(\Laminas\Form\ElementInterface $element): ?string {}
    }

    class FormRow extends \Laminas\Form\View\Helper\AbstractHelper
    {
        public const LABEL_APPEND  = 'append';
        public const LABEL_PREPEND = 'prepend';
        /**
         * The class that is added to element that have errors
         *
         * @var string
         */
        protected $inputErrorClass = 'input-error';
        /**
         * The attributes for the row label
         *
         * @var array
         */
        protected $labelAttributes = [];
        /**
         * Where will be label rendered?
         *
         * @var string
         */
        protected $labelPosition = self::LABEL_PREPEND;
        /**
         * Are the errors are rendered by this helper?
         *
         * @var bool
         */
        protected $renderErrors = true;
        /**
         * Form label helper instance
         *
         * @var null|FormLabel
         */
        protected $labelHelper;
        /**
         * Form element helper instance
         *
         * @var null|FormElement
         */
        protected $elementHelper;
        /**
         * Form element errors helper instance
         *
         * @var null|FormElementErrors
         */
        protected $elementErrorsHelper;
        /** @var null|string */
        protected $partial;

        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormRow
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, ?string $labelPosition = null, ?bool $renderErrors = null, ?string $partial = null) {}

        /**
         * Utility form helper that renders a label (if it exists), an element and errors
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element, ?string $labelPosition = null): string {}

        /**
         * Set the class that is added to element that have errors
         *
         * @return $this
         */
        public function setInputErrorClass(string $inputErrorClass) {}

        /**
         * Get the class that is added to element that have errors
         */
        public function getInputErrorClass(): string {}

        /**
         * Set the attributes for the row label
         *
         * @return $this
         */
        public function setLabelAttributes(array $labelAttributes) {}

        /**
         * Get the attributes for the row label
         *
         * @return array
         */
        public function getLabelAttributes(): array {}

        /**
         * Set the label position
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setLabelPosition(string $labelPosition) {}

        /**
         * Get the label position
         */
        public function getLabelPosition(): string {}

        /**
         * Set if the errors are rendered by this helper
         *
         * @return $this
         */
        public function setRenderErrors(bool $renderErrors) {}

        /**
         * Retrieve if the errors are rendered by this helper
         */
        public function getRenderErrors(): bool {}

        /**
         * Set a partial view script to use for rendering the row
         *
         * @return $this
         */
        public function setPartial(?string $partial) {}

        /**
         * Retrieve current partial
         */
        public function getPartial(): ?string {}

        /**
         * Retrieve the FormLabel helper
         */
        protected function getLabelHelper(): \Laminas\Form\View\Helper\FormLabel {}

        /**
         * Retrieve the FormElement helper
         */
        protected function getElementHelper(): \Laminas\Form\View\Helper\FormElement {}

        /**
         * Retrieve the FormElementErrors helper
         */
        protected function getElementErrorsHelper(): \Laminas\Form\View\Helper\FormElementErrors {}
    }

    class FormLabel extends \Laminas\Form\View\Helper\AbstractHelper
    {
        public const APPEND  = 'append';
        public const PREPEND = 'prepend';
        /**
         * Attributes valid for the label tag
         *
         * @var array
         */
        protected $validTagAttributes = ['for' => true, 'form' => true];

        /**
         * Generate a form label, optionally with content
         *
         * Always generates a "for" statement, as we cannot assume the form input
         * will be provided in the $labelContent.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormLabel
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, ?string $labelContent = null, ?string $position = null) {}

        /**
         * Generate an opening label tag
         *
         * @param null|array|\Laminas\Form\ElementInterface $attributesOrElement
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function openTag($attributesOrElement = null): string {}

        /**
         * Return a closing label tag
         */
        public function closeTag(): string {}
    }

    class FormDateSelect extends \Laminas\Form\View\Helper\AbstractFormDateSelect
    {
        /**
         * Invoke helper as function
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|self
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, int $dateType = \IntlDateFormatter::LONG, ?string $locale = null) {}

        /**
         * Render a date element that is composed of three selects
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Create a key => value options for days
         *
         * @param string $pattern Pattern to use for days
         *
         * @return array
         */
        protected function getDaysOptions(string $pattern): array {}
    }

    class FormCaptcha extends \Laminas\Form\View\Helper\AbstractHelper
    {
        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\Element\Captcha
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormCaptcha
         */
        public function __invoke(?\Laminas\Form\Element\Captcha $element = null) {}

        /**
         * Render a form captcha for an element
         *
         * @throws \Laminas\Form\Exception\DomainException If the element does not compose a captcha, or the renderer does
         *                                   not implement plugin().
         */
        public function render(\Laminas\Form\Element\Captcha $element): string {}
    }

    class FormNumber extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="number"
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'list' => true, 'max' => true,
                                         'min'  => true, 'step' => true, 'placeholder' => true, 'readonly' => true, 'required' => true, 'type' => true, 'value' => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormRange extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="range"
         *
         * @var array
         */
        protected $validTagAttributes = ['name' => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'list' => true, 'max' => true,
                                         'min'  => true, 'step' => true, 'required' => true, 'type' => true, 'value' => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormPassword extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="password"
         *
         * @var array
         */
        protected $validTagAttributes = ['name'      => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'maxlength' => true,
                                         'minlength' => true, 'pattern' => true, 'placeholder' => true, 'readonly' => true, 'required' => true, 'size' => true, 'type' => true,
                                         'value'     => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormDate extends \Laminas\Form\View\Helper\AbstractFormDateTime
    {
        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormTime extends \Laminas\Form\View\Helper\AbstractFormDateTime
    {
        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormButton extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the button tag
         *
         * @var array
         */
        protected $validTagAttributes = ['name'       => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'formaction' => true, 'formenctype' => true,
                                         'formmethod' => true, 'formnovalidate' => true, 'formtarget' => true, 'type' => true, 'value' => true];
        /**
         * Valid values for the button type
         *
         * @var array
         */
        protected $validTypes = ['button' => true, 'reset' => true, 'submit' => true];

        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormButton
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, ?string $buttonContent = null) {}

        /**
         * Render a form <button> element from the provided $element,
         * using content from $buttonContent or the element's "label" attribute
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element, ?string $buttonContent = null): string {}

        /**
         * Generate an opening button tag
         *
         * @param null|array|\Laminas\Form\ElementInterface $attributesOrElement
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function openTag($attributesOrElement = null): string {}

        /**
         * Return a closing button tag
         */
        public function closeTag(): string {}

        /**
         * Determine button type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormSelect extends \Laminas\Form\View\Helper\AbstractHelper
    {
        /**
         * Attributes valid for select
         *
         * @var array
         */
        protected $validSelectAttributes = ['name' => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'multiple' => true, 'required' => true,
                                            'size' => true];
        /**
         * Attributes valid for options
         *
         * @var array
         */
        protected $validOptionAttributes = ['disabled' => true, 'selected' => true, 'label' => true, 'value' => true];
        /**
         * Attributes valid for option groups
         *
         * @var array
         */
        protected $validOptgroupAttributes = ['disabled' => true, 'label' => true];
        /** @var array<string, bool> */
        protected $translatableAttributes = ['label' => true];
        /** @var FormHidden|null */
        protected $formHiddenHelper;

        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|FormSelect
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null) {}

        /**
         * Render a form <select> element from the provided $element
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Render an array of options
         *
         * Individual options should be of the form:
         *
         * <code>
         * array(
         *     'value'    => 'value',
         *     'label'    => 'label',
         *     'disabled' => $booleanFlag,
         *     'selected' => $booleanFlag,
         * )
         * </code>
         *
         * @param array $options
         * @param array $selectedOptions Option values that should be marked as selected
         */
        public function renderOptions(array $options, array $selectedOptions = []): string {}

        /**
         * Render an optgroup
         *
         * See {@link renderOptions()} for the options specification. Basically,
         * an optgroup is simply an option that has an additional "options" key
         * with an array following the specification for renderOptions().
         *
         * @param array $optgroup
         * @param array $selectedOptions
         */
        public function renderOptgroup(array $optgroup, array $selectedOptions = []): string {}

        /**
         * Ensure that the value is set appropriately
         *
         * If the element's value attribute is an array, but there is no multiple
         * attribute, or that attribute does not evaluate to true, then we have
         * a domain issue -- you cannot have multiple options selected unless the
         * multiple attribute is present and enabled.
         *
         * @param array $attributes
         *
         * @return array
         * @throws \Laminas\Form\Exception\DomainException
         */
        protected function validateMultiValue(mixed $value, array $attributes): array {}

        protected function renderHiddenElement(\Laminas\Form\Element\Select $element): string {}

        protected function getFormHiddenHelper(): \Laminas\Form\View\Helper\FormHidden {}
    }

    class FormTel extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Attributes valid for the input tag type="tel"
         *
         * @var array
         */
        protected $validTagAttributes = ['name'      => true, 'autocomplete' => true, 'autofocus' => true, 'disabled' => true, 'form' => true, 'list' => true, 'maxlength' => true,
                                         'minlength' => true, 'pattern' => true, 'placeholder' => true, 'readonly' => true, 'required' => true, 'size' => true, 'type' => true,
                                         'value'     => true];

        /**
         * Determine input type to use
         */
        protected function getType(\Laminas\Form\ElementInterface $element): string {}
    }

    class FormMonthSelect extends \Laminas\Form\View\Helper\AbstractFormDateSelect
    {
        /**
         * Invoke helper as function
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|self
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null, int $dateType = \IntlDateFormatter::LONG, ?string $locale = null) {}

        /**
         * Render a month element that is composed of two selects
         *
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}
    }
}

namespace Laminas\Form\View\Helper\Factory {
    final class FormElementErrorsFactory
    {
        public function __invoke(\Psr\Container\ContainerInterface $container): \Laminas\Form\View\Helper\FormElementErrors {}
    }
}

namespace Laminas\Form\View\Helper\File {
    /**
     * A view helper to render the hidden input with a UploadProgress id
     * for file uploads progress tracking.
     */
    class FormFileUploadProgress extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null): string {}

        /**
         * Render a hidden form <input> element with the progress id
         */
        public function renderHiddenId(): string {}

        protected function getName(): string {}

        protected function getValue(): string {}
    }

    /**
     * A view helper to render the hidden input with a Session progress id
     * for file uploads progress tracking.
     */
    class FormFileSessionProgress extends \Laminas\Form\View\Helper\File\FormFileUploadProgress
    {
        protected function getName(): string {}
    }

    /**
     * A view helper to render the hidden input with a Session progress id
     * for file uploads progress tracking.
     */
    class FormFileApcProgress extends \Laminas\Form\View\Helper\File\FormFileUploadProgress
    {
        protected function getName(): string {}
    }
}

namespace Laminas\Form\View\Helper\Captcha {
    abstract class AbstractWord extends \Laminas\Form\View\Helper\FormInput
    {
        public const CAPTCHA_APPEND  = 'append';
        public const CAPTCHA_PREPEND = 'prepend';
        /** @var string */
        protected $captchaPosition = self::CAPTCHA_APPEND;
        /**
         * Separator string for captcha and inputs
         *
         * @var string
         */
        protected $separator = '';

        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|self
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null) {}

        /**
         * Render captcha form elements for the given element
         *
         * Creates and returns:
         * - Hidden input with captcha identifier (name[id])
         * - Text input for entering captcha value (name[input])
         *
         * More specific renderers will consume this and render it.
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        protected function renderCaptchaInputs(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Render the hidden input with the captcha identifier
         */
        protected function renderCaptchaHidden(\Laminas\Captcha\AdapterInterface $captcha, array $attributes): string {}

        /**
         * Render the input for capturing the captcha value from the client
         */
        protected function renderCaptchaInput(\Laminas\Captcha\AdapterInterface $captcha, array $attributes): string {}

        /**
         * Set value for captchaPosition
         *
         * @return $this
         * @throws \Laminas\Form\Exception\InvalidArgumentException
         */
        public function setCaptchaPosition(string $captchaPosition) {}

        /**
         * Get position of captcha
         */
        public function getCaptchaPosition(): string {}

        /**
         * Set separator string for captcha and inputs
         *
         * @return $this
         */
        public function setSeparator(string $separator) {}

        /**
         * Get separator for captcha and inputs
         */
        public function getSeparator(): string {}
    }

    class Dumb extends \Laminas\Form\View\Helper\Captcha\AbstractWord
    {
        /**
         * Render the captcha
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}
    }

    class ReCaptcha extends \Laminas\Form\View\Helper\FormInput
    {
        /**
         * Invoke helper as functor
         *
         * Proxies to {@link render()}.
         *
         * @template T as null|\Laminas\Form\ElementInterface
         * @psalm-param T $element
         * @psalm-return (T is null ? self : string)
         * @return string|self
         */
        public function __invoke(?\Laminas\Form\ElementInterface $element = null) {}

        /**
         * Render ReCaptcha form elements
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}

        /**
         * Render hidden input element if the element's name is not 'g-recaptcha-response'
         * so that required validation works
         */
        protected function renderHiddenInput(string $name): string {}
    }

    class Figlet extends \Laminas\Form\View\Helper\Captcha\AbstractWord
    {
        /**
         * Render the captcha
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}
    }

    class Image extends \Laminas\Form\View\Helper\Captcha\AbstractWord
    {
        /**
         * Render the captcha
         *
         * @throws \Laminas\Form\Exception\DomainException
         */
        public function render(\Laminas\Form\ElementInterface $element): string {}
    }
}

namespace Laminas\Form\View {
    /**
     * Helper trait for auto-completion of code in modern IDEs.
     *
     * The trait provides convenience methods for view helpers,
     * defined by the laminas-form component. It is designed to be used
     * for type-hinting $this variable inside laminas-view templates via doc blocks.
     *
     * The base class is PhpRenderer, followed by the helper trait from
     * the laminas-form component. However, multiple helper traits from different
     * Laminas components can be chained afterwards.
     *
     * @example @var \Laminas\View\Renderer\PhpRenderer|\Laminas\Form\View\HelperTrait $this
     *
     * @method string|\Laminas\Form\View\Helper\Form form(\Laminas\Form\FormInterface|null $form = null)
     * @method string|\Laminas\Form\View\Helper\FormButton formButton(\Laminas\Form\ElementInterface|null $element = null, string|null $buttonContent = null)
     * @method string|\Laminas\Form\View\Helper\FormCaptcha formCaptcha(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\Captcha\Dumb formCaptchaDumb(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\Captcha\Figlet formCaptchaFiglet(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\Captcha\Image formCaptchaImage(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\Captcha\ReCaptcha formCaptchaRecaptcha(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormCheckbox formCheckbox(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormCollection formCollection(\Laminas\Form\ElementInterface|null $element = null, bool $wrap = true)
     * @method string|\Laminas\Form\View\Helper\FormColor formColor(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormDate formDate(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormDateTime formDateTime(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormDateTimeLocal formDateTimeLocal(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormDateTimeSelect formDateTimeSelect(\Laminas\Form\ElementInterface|null $element = null, int $dateType = \IntlDateFormatter::LONG, int|null|string $timeType = \IntlDateFormatter::LONG, string|null $locale = null)
     * @method string|\Laminas\Form\View\Helper\FormDateSelect formDateSelect(\Laminas\Form\ElementInterface $element = null, $dateType = \IntlDateFormatter::LONG, $locale = null)
     * @method string|\Laminas\Form\View\Helper\FormElement formElement(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormElementErrors formElementErrors(\Laminas\Form\ElementInterface|null $element = null, array $attributes = [])
     * @method string|\Laminas\Form\View\Helper\FormEmail formEmail(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormFile formFile(\Laminas\Form\ElementInterface|null $element = null)
     * @method string formFileApcProgress(\Laminas\Form\ElementInterface|null $element = null)
     * @method string formFileSessionProgress(\Laminas\Form\ElementInterface|null $element = null)
     * @method string formFileUploadProgress(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormHidden formHidden(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormImage formImage(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormInput formInput(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormLabel formLabel(\Laminas\Form\ElementInterface|null $element = null, string|null $labelContent = null, string|null $position = null)
     * @method string|\Laminas\Form\View\Helper\FormMonth formMonth(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormMonthSelect formMonthSelect(\Laminas\Form\ElementInterface|null $element = null, int $dateType = \IntlDateFormatter::LONG, string|null $locale = null)
     * @method string|\Laminas\Form\View\Helper\FormMultiCheckbox formMultiCheckbox(\Laminas\Form\ElementInterface|null $element = null, string|null $labelPosition = null)
     * @method string|\Laminas\Form\View\Helper\FormNumber formNumber(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormPassword formPassword(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormRadio formRadio(\Laminas\Form\ElementInterface|null $element = null, string|null $labelPosition = null)
     * @method string|\Laminas\Form\View\Helper\FormRange formRange(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormReset formReset(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormRow formRow(\Laminas\Form\ElementInterface|null $element = null, string|null $labelPosition = null, bool|null $renderErrors = null, string|null $partial = null)
     * @method string|\Laminas\Form\View\Helper\FormSearch formSearch(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormSelect formSelect(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormSubmit formSubmit(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormTel formTel(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormText formText(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormTextarea formTextarea(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormTime formTime(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormUrl formUrl(\Laminas\Form\ElementInterface|null $element = null)
     * @method string|\Laminas\Form\View\Helper\FormWeek formWeek(\Laminas\Form\ElementInterface|null $element = null)
     */
    trait HelperTrait
    {
    }
}
